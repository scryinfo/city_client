---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xuyafang.
--- DateTime: 2019/2/27 18:13
---Land auction
MapRightGroundAucPage = class('MapRightGroundAucPage', MapRightPageBase)

--Initialization method
function MapRightGroundAucPage:initialize(viewRect)
    self.viewRect = viewRect:GetComponent("RectTransform")

    local tran = self.viewRect.transform
    self.closeBtn = tran:Find("closeBtn"):GetComponent("Button")
    self.goHereBtn = tran:Find("goHereBtn"):GetComponent("Button")
    self.titleText = tran:Find("titleText"):GetComponent("Text")
    self.timeDownText = tran:Find("timeDownRoot/timeDownText"):GetComponent("Text")  --Countdown
    self.soonRoot = tran:Find("soon")
    self.soonStartTime = tran:Find("soon/startTime")
    self.soonPrice = tran:Find("soon/price")

    self.nowRoot = tran:Find("now")
    self.nowPrice = tran:Find("now/price")
    self.noneHistoryRoot = tran:Find("now/noneBid")

    self.historyRoot = tran:Find("now/historyRoot")
    self.historyContent = tran:Find("now/historyRoot/scrollRect/content")
    self.historyItemPrefab = tran:Find("now/historyRoot/GAucHistoryItem")

    self.hourText01 = tran:Find("timeDownRoot/Text01"):GetComponent("Text")
    self.minuteText02 = tran:Find("timeDownRoot/Text02"):GetComponent("Text")
    self.secondText03 = tran:Find("timeDownRoot/Text03"):GetComponent("Text")
    self.noneHistoryText04 = tran:Find("now/noneBid/noneBidText"):GetComponent("Text")
    self.goHereBtnText05 = tran:Find("goHereBtn/Text"):GetComponent("Text")

    self.closeBtn.onClick:AddListener(function ()
        PlayMusEff(1002)
        self:close()
    end)
    self.goHereBtn.onClick:AddListener(function ()
        PlayMusEff(1002)
        self:_goHereBtn()
    end)
    self.m_Timer = Timer.New(slot(self._itemTimer, self), 1, -1, true)
end
--
function MapRightGroundAucPage:refreshData(data)
    self.viewRect.anchoredPosition = Vector2.zero
    self.data = data.detailData
    if self.data == nil then
        return
    end

    self:_addListener()
    self.m_Timer:Reset(slot(self._itemTimer, self), 1, -1, true)
    self.m_Timer:Start()

    local groundInfo = GroundAucConfig[self.data.id]
    --If you start an auction, you still need to determine whether someone is bidding
    if self.data.isStartAuc then
        self:setSoonAndNow(true)
        self:refreshNow(groundInfo.basePrice)

        --Determine if someone is bidding
        if self.data.endTs == nil or self.data.endTs == 0 then
            self:setBidState(false)
            self:setTimeValue(0)
        else
            self:setBidState(true)
            self.bidHistory = ct.deepCopy(self.data.bidHistory)
            self:_createHistory()
            self.historyContent.localPosition = Vector2.zero
            self.startTimeDownForFinish = true  --Countdown to the end of the auction
            self:NowTimeDownFunc()
        end
    else
        self:setSoonAndNow(false)
        self:refreshSoon(groundInfo.beginTime, groundInfo.basePrice)
        self.startTimeDownForStart = true  --Countdown to upcoming auction
        self:SoonTimeDownFunc()
    end
    self:openShow()
end
--Refresh the display data of starting auction
function MapRightGroundAucPage:refreshNow(basePrice)
    if self.nowPriceItem == nil then
        self.nowPriceItem = MapRightShowInfoItem:new(self.nowPrice)
    end
    local str = string.format("<color=%s>E%s</color>", MapRightGroundTransPage.moneyColor, GetClientPriceString(basePrice))
    local tempData = {infoTypeStr = "GAucPrice", value = str}
    self.nowPriceItem:initData(tempData)
end
--Refresh the display data of the upcoming auction
function MapRightGroundAucPage:refreshSoon(beginTime, basePrice)
    if self.soonStartTimeItem == nil then
        self.soonStartTimeItem = MapRightShowInfoItem:new(self.soonStartTime)
    end
    if self.soonPriceItem == nil then
        self.soonPriceItem = MapRightShowInfoItem:new(self.soonPrice)
    end
    local timeData = getFormatUnixTime(beginTime)
    local str1 = timeData.hour..":"..timeData.minute..":"..timeData.second
    local tempData1 = {infoTypeStr = "GAucTime", value = str1}
    self.soonStartTimeItem:initData(tempData1)
    local str2 = string.format("<color=%s>E%s</color>", MapRightGroundTransPage.moneyColor, GetClientPriceString(basePrice))
    local tempData2 = {infoTypeStr = "GAucPrice", value = str2}
    self.soonPriceItem:initData(tempData2)
end
--Reset state
function MapRightGroundAucPage:openShow()
    self:_language()
    self.viewRect.anchoredPosition = Vector2.zero
end
--multi-language
function MapRightGroundAucPage:_language()
    self.hourText01.text = GetLanguage(20160004)
    self.minuteText02.text = GetLanguage(20160005)
    self.secondText03.text = GetLanguage(20160006)
    self.noneHistoryText04.text = GetLanguage(20160009)
    self.titleText.text = GetLanguage(21010001)
    self.goHereBtnText05.text = GetLanguage(20010008)
end
--shut down
function MapRightGroundAucPage:close()
    if self.data == nil then
        return
    end
    self.viewRect.anchoredPosition = Vector2.New(506, 0)
    if self.m_Timer ~= nil then
        self.m_Timer:Stop()
    end

    self.startTimeDownForStart = false
    self.startTimeDownForFinish = false
    self:_removeListener()
    self:_cleanHistoryObj()
    self.bidHistory = {}
    self.data = nil
end
--Go to a building on the map
function MapRightGroundAucPage:_goHereBtn()
    local tempData = self.data
    local temp = GroundAucConfig[self.data.id].centerPos
    MapBubbleManager.GoHereFunc(temp)

    ct.OpenCtrl("GroundAuctionCtrl", tempData)
end

------------------
function MapRightGroundAucPage:_addListener()
    Event.AddListener("c_BidInfoUpdate", self._mapBidInfoUpdate, self)
    Event.AddListener("c_BidEnd", self._mapBidEnd, self)
    Event.AddListener("c_BidStart", self._mapBidStart, self)
    Event.AddListener("c_ReturnGAucHistoryObj", self._returnHistoryObj, self)
end
function MapRightGroundAucPage:_removeListener()
    Event.RemoveListener("c_BidInfoUpdate", self._mapBidInfoUpdate, self)
    Event.RemoveListener("c_BidEnd", self._mapBidEnd, self)
    Event.RemoveListener("c_BidStart", self._mapBidStart, self)
    Event.RemoveListener("c_ReturnGAucHistoryObj", self._returnHistoryObj, self)
end
--
function MapRightGroundAucPage:_itemTimer()
    self:SoonTimeDownFunc()
    self:NowTimeDownFunc()
end
--Simple Pool of History
function MapRightGroundAucPage:_createHistory()
    self:_cleanHistory()  --Clear history item

    table.sort(self.bidHistory, function (m, n) return m.ts > n.ts end)
    for i, value in ipairs(self.bidHistory) do
        if i == 1 then
            value.isFirst = true
        else
            value.isFirst = false
        end
        local go = self:_getValuableHistoryObj()
        go.transform:SetParent(self.historyContent.transform)
        go.transform.localScale = Vector3.one
        self.historyLuaItems[i] = MapGAucHistoryItem:new(value, go.transform)
    end
end
--Get a valid item
function MapRightGroundAucPage:_getValuableHistoryObj()
    if self.historyObjs == nil or #self.historyObjs == 0 then
        local go = UnityEngine.GameObject.Instantiate(self.historyItemPrefab)
        --go.transform.localScale = Vector3.one
        return go
    else
        local go = self.historyObjs[1]
        --go.transform.localScale = Vector3.one
        table.remove(self.historyObjs, 1)
        return go
    end
end
--Recycle obj
function MapRightGroundAucPage:_returnHistoryObj(go)
    if self.historyObjs == nil then
        self.historyObjs = {}
    end
    go.transform:SetParent(self.historyRoot.transform)
    go.transform.localScale = Vector3.zero
    table.insert(self.historyObjs, 1, go)
end
--Clear the record when hiding the interface
function MapRightGroundAucPage:_cleanHistoryObj()
    if self.historyObjs == nil then
        return
    end
    for i, go in pairs(self.historyObjs) do
        go.transform:SetParent(self.historyRoot.transform)
        go.transform.localScale = Vector3.zero
    end
end

---Countdown---
-- Countdown to upcoming auction
function MapRightGroundAucPage:SoonTimeDownFunc()
    if self.startTimeDownForStart == true then
        local startAucTime = GroundAucConfig[self.data.id].beginTime * 1000
        local remainTime = startAucTime - TimeSynchronized.GetTheCurrentServerTime()
        if remainTime <= 0 then
            self.startTimeDownForStart = false
            return
        end

        self:setTimeValue(remainTime / 1000)
    end
end
--Countdown to the end of the auction
function MapRightGroundAucPage:NowTimeDownFunc()
    if self.startTimeDownForFinish == true then
        if self.data.endTs == nil then
            return
        end
        local finishTime = self.data.endTs
        local remainTime = finishTime - TimeSynchronized.GetTheCurrentServerTime()
        if remainTime < 0 then
            self.startTimeDownForFinish = false
            self:close()
            return
        end

        self:setTimeValue(remainTime / 1000)
    end
end
--
function MapRightGroundAucPage:setTimeValue(remainTime)
    local timeTable = getTimeTable(remainTime)
    local hour = self:getValuableStr(timeTable.hour)
    local minute = self:getValuableStr(timeTable.minute)
    local second = self:getValuableStr(timeTable.second)
    self.timeDownText.text = string.format("%s     %s     %s", hour, minute, second)
end
--
function MapRightGroundAucPage:getValuableStr(str)
    if string.len(str) ~= 2 then
        return
    end
    local firstChar = string.sub(str, 1, 1)
    local secondChar = string.sub(str, 2, 2)
    return firstChar.."   "..secondChar
end

--Auction information update
function MapRightGroundAucPage:_mapBidInfoUpdate(data)
    if data.id ~= self.data.id then
        return
    end

    self:setBidState(true)
    -- Make a wrong judgment about whether the current historical highest price is correct --
    self:_checkHighestPrice(data)

    self:_cleanHistory()
    self:_createHistory()
    self.startTimeDownForFinish = true
    self:NowTimeDownFunc()
end
--Determine whether it is the highest price
function MapRightGroundAucPage:_checkHighestPrice(data)
    if self.bidHistory == nil then
        self.bidHistory = {}
        local temp = {biderId = data.biderId, price = data.price, ts = data.ts}
        table.insert(self.bidHistory, 1, temp)
        self.data.endTs = data.ts + GAucModel.BidTime
        return
    end

    local tempHigh = self.bidHistory[1]
    if tempHigh.price < data.price then
        local temp = {biderId = data.biderId, price = data.price, ts = data.ts}
        table.insert(self.bidHistory, 1, temp)
        self.data.endTs = data.ts + GAucModel.BidTime
    end
end
--Clear history item
function MapRightGroundAucPage:_cleanHistory()
    if self.historyLuaItems ~= nil and #self.historyLuaItems ~= 0 then
        for i, value in pairs(self.historyLuaItems) do
            value:close()
            value = nil
        end
    end
    self.historyLuaItems = {}
end

--End of auction
function MapRightGroundAucPage:_mapBidEnd(id)
    if id == self.data.id then
        self:close()
    end
end
--Start auction
function MapRightGroundAucPage:_mapBidStart(groundData)
    if groundData.id ~= self.data.id then
        return
    end

    self:setSoonAndNow(true)
    self:setBidState(false)
    self:refreshNow(GroundAucConfig[self.data.id].basePrice)
end

--Did anyone bid in the auction
function MapRightGroundAucPage:setBidState(hasBid)
    if hasBid == true then
        self.historyRoot.localScale = Vector3.one
        self.noneHistoryRoot.localScale = Vector3.zero
    else
        self.historyRoot.localScale = Vector3.zero
        self.noneHistoryRoot.localScale = Vector3.one
    end
end
--In or about to auction
function MapRightGroundAucPage:setSoonAndNow(isNow)
    if isNow == true then
        self.soonRoot.localScale = Vector3.zero
        self.nowRoot.localScale = Vector3.one
    else
        self.soonRoot.localScale = Vector3.one
        self.nowRoot.localScale = Vector3.zero
    end
end
------------------