---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cyz_scry.
--- DateTime: 2018/9/19 13:02
--[[
1. The role of grouping
    1. Group test cases to avoid running time irrelevant test cases
    2. The log/log also uses the same grouping strategy to avoid the development of irrelevant logs.
2. How to use
1. Activate the group
Example:
    TestGroup.active_TestGroup("abel_w3")
* Activate the group with id "abel_w3". After activation, all tests and logs using this group id will work normally
2. Register the group in the specific unit test definition
1. require:
UnitTest = require ('test/testFrameWork/UnitTest')
2. Define test cases
Example:
UnitTest.Exec("abel_w4", "test_pb11111", function ()
ct.log("abel_w4","[test_pb11111] Test completed")
end)
* "Abel_w4" here is the Id of the test group. If the test group is not activated, the unit test will not be executed
* test_pb11111 is the name of the test case function
* behind function is the body of the test case
3. Use test grouping in non-unit tested code
    1. There is only one case of using test grouping in ordinary code, that is, log grouping, to avoid the interference of irrelevant logs
2. The log of our project uniformly uses the interface ct.log(...). It should be noted that the print method that comes with lua is not available now.
Examples:
ct.log("abel_w4","[test_pb11111] Test completed")
* "Abel_w4" here is the group id. If the group corresponding to the id is not activated, this log will be invalid;
3. Description:
1. The definition of the test case actually calls this method:
function UnitTest.Exec(unitGroupId, funcName, func)
The unitGroupId in the parameter is the Id of the test group
2. Description of method parameters
1. unitGroupId test group Id
1. Naming format: English name_work week_extra information, for example: allen_w6_temp
2. Function: The unique ID of the test group. A group ID can be shared by multiple test cases and log commands. Once the ID group is activated by active_TestGroup, all test cases and log commands that share the ID will be executed.
2, funcName test case function name
1. The function name must start with test_, for example: test_login, otherwise it will not be executed
2. Require global uniqueness
3. Method implementation of func test cases
]]--
local ProFi = require ('test/testFrameWork/memory/ProFi')
local mri = MemoryRefInfo
ct.mkMemoryProfile()
UnitTest = {}

UnitTest.startGroup = {}
UnitTest.endGroup = {}

function UnitTest.TestBlockStart()
    --local info = debug.getinfo(1) --Current stack area
    local info = debug.getinfo(2) -- the stack area where the method is called
    assert(UnitTest.startGroup[info.short_src] == nil, "Note: Only one pair of ExecStart and ExecEnd in a file")
    UnitTest.startGroup[info.short_src]=1
end

function UnitTest.TestBlockEnd()
    local info = debug.getinfo(2)
    assert(UnitTest.startGroup[info.short_src] == 1, "Note: No corresponding ExecStart found")
    assert(UnitTest.endGroup[info.short_src] ~= 1, "Note: There can only be one pair of ExecStart and ExecEnd in a file")
    UnitTest.endGroup[info.short_src]=1
end

function UnitTest.CheckValidExec()
    local info = debug.getinfo(3)
    return UnitTest.startGroup[info.short_src] ~= nil and UnitTest.endGroup[info.short_src] == nil
end

function UnitTest.Exec(unitGroupId, funcName, func)
    assert(UnitTest.CheckValidExec(), "The test case must be located in the test area, ie: after TestBlockStart and before TestBlockEnd ")
    if TestGroup.get_TestGroupId(unitGroupId) == nil then
    return
    end
    addToTestGropu(funcName, unitGroupId)
    _G[funcName] = func
    end

--CPU usage analysis, can only be used inside UnitTest.Exec
function UnitTest.PerformanceTest(groupid, info,func)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    --ct.log(groupid,info)
    local startTime = os.clock()
    func(groupid)
    local endTime = os.clock()
    local outtime = endTime - startTime
    ct.log(groupid, info, "execution time: ", outtime)
     return outtime
end

--Memory usage analysis, generate memory usage before and after execution of func to the folder MemoryProfile
function UnitTest.MemoryConsumptionTest(groupid, funcName, func)
     if TestGroup.get_TestGroupId(groupid) == nil then return end
     ct.log(groupid, funcName)
     ProFi:reset()
     collectgarbage("collect")
     ProFi:checkMemory( 0, funcName..'-------------')
     ProFi:writeReport( funcName..'_0_before.txt')
     collectgarbage("collect")
     ProFi:start()
     func(groupid)
     ProFi:stop()
     ProFi:checkMemory( 0, funcName..'-------------')
     ProFi:writeReport( funcName..'_1_after.txt')
     ProFi:reset()
     collectgarbage("collect")
     ProFi:checkMemory( 0, funcName..'-------------')
     ProFi:writeReport( funcName..'_2_finished.txt')
end

--File naming convention
function UnitTest.GetDumpAllFileName(groupid, filename)
    return "["..groupid.."]".."_DumpAll_"..filename
end

function UnitTest.GetDumpOneFileName(groupid, filename)
    return "["..groupid.."]".."_DumpOne_"..filename
end

function UnitTest.GetValidPath(groupid, filename)
    return UnitTest.GetDumpAllFileName(groupid, filename)..".txt"
end

--Global memory reference analysis
function UnitTest.MemoryReferenceAll(groupid, fileName, rootObj)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    local root = nil
    if rootObj ~= nil then
        root  = rootObj
    end
    collectgarbage("collect")
    mri.m_cMethods.DumpMemorySnapshot(ct.getMemoryProfile().."/", UnitTest.GetDumpAllFileName(groupid,fileName), -1, tostring(root), root)
end

--Designated object memory reference analysis, can only be used inside UnitTest.Exec
function UnitTest.MemoryReferenceOne(groupid, markid,object)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    collectgarbage("collect")
    mri.m_cMethods.DumpMemorySnapshotSingleObject(ct.getMemoryProfile().."/", UnitTest.GetDumpOneFileName(groupid,markid), -1, objectName, object)
end

--Compare the difference in citation information between two files
function UnitTest.MemoryRefResaultCompared(groupid, firstfile, secondfile)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    mri.m_cMethods.DumpMemorySnapshotComparedFile(ct.getMemoryProfile().."/", "Compared_"..UnitTest.GetDumpAllFileName(groupid, firstfile).."-"..secondfile, -1,  UnitTest.GetValidPath(groupid, firstfile), UnitTest.GetValidPath(groupid, secondfile))
end

--Filter reference statistics of specific objects in the specified file
function UnitTest.MemoryRefResaultFiltered(groupid, strFilePath, strFilter, bIncludeFilter)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    mri.m_cBases.OutputFilteredResult(UnitTest.GetDumpAllFileName(groupid,strFilePath), strFilter, bIncludeFilter, true)
end

--Use the following interface to execute the corresponding unit test at a specific time and condition. Using the message mechanism, you need to register the corresponding event message in the corresponding unit test
function UnitTest.Exec_now(groupid, event,...)
    if TestGroup.get_TestGroupId(groupid) == nil  then return end
    Event.Brocast(event,...);
end


AsyncSequenceTester = class('AsyncSequenceTester')
AsyncSequenceTester.static.testers = nil

function AsyncSequenceTester.recordTester(newTester)
    AsyncSequenceTester.static.testers = newTester
end

function AsyncSequenceTester.Tester()
    return AsyncSequenceTester.static.testers
end

function AsyncSequenceTester:resetData()
end

function AsyncSequenceTester:initialize()
    self:resetData()
end

function AsyncSequenceTester:excute()
    local curSeq = self:getCurSeq()
    if curSeq == nil then
        return
    end
    if curSeq.prefun ~= nil then
        curSeq:prefun()
    end
    self.startTime = os.clock()
    if curSeq then
        curSeq.fun(self,curSeq)
    end
end

function AsyncSequenceTester:printExcuteTime()
    for i, v in pairs(self.testSquence) do
        ct.log('system',v.msg..v.excutetime)
    end
end

function AsyncSequenceTester:getCurSeq()
    return self.testSquence[self.curPos]
end
function AsyncSequenceTester:Nextfun()
    self.curPos = self.curPos + 1
end

return UnitTest