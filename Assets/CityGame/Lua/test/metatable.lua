---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cyz_scry.
--- DateTime: 2018/9/17 16:37
---

UnitTest.TestBlockStart()---------------------------------------------------------

local lu = require "Framework/pbl/luaunit"
local notEq = lu.assertEvalToFalse
local eq       = lu.assertEquals
local table_eq = lu.assertItemsEquals
local fail     = lu.assertErrorMsgContains
local log = log

local parent = {
    house = 1
}

parent.__index = parent    --If there is no such sentence, even if the parent is set to the metatable, the content in the parent cannot be found. The content pointed to by __index is nil (Supplement: more importantly, the derived class cannot be dynamically bound)

--__index has only two formal parameters, table and key. The third parameter here is nil, so it is only suitable for search operations, not for assignment operations. If there is no corresponding key in the current table, then find the corresponding _ in the original table _index refers to the method or table to perform the search operation
-- __index deals with the lookup of the key in the table; __newindex handles the assignment of the key in the table
--parent.__index = function ( t, k ,v )
--    -- t[k] = v
--    local ret = 0
--    if k == "house" then
--        parent[k] = 2
--        ret = 123
--    end
--    return ret
--end

--parent.__index = {
--    house = "1111",
--}
local child = {
    wife = 2
}

local returnTb = setmetatable(child, parent) --setmetatable The return value is the first table in the incoming parameters

ct.log("[metatable] setmetatable child"..tostring(child))
ct.log("[metatable] setmetatable parent"..tostring(parent))
ct.log("[metatable] setmetatable returnTb"..tostring(returnTb))

ct.log("[metatable] __index test: child.house"..tostring(child.house))
ct.log("[metatable] __index test: child.wife"..tostring(child.wife))

parent.__newindex = function (t, k ,v) --Assignment operation, if there is no corresponding key in the current table, then find the method or table pointed to by the corresponding __newindex in the original table to perform the assignment operation
    -- t[k] = v
    if k == "house" then
        parent[k] = v * 2
    end
end
-- equal to
-- parent.__newindex = parent

UnitTest.Exec("abel_w4", "test_metatable__newindex",  function ()
    child.house = 3
    child.wife = 4

    ct.log('abel_w4','[test__newindex] parent.__newindex not nil, child.house',tostring(child.house))
    ct.log('abel_w4','[test__newindex] parent.__newindex not nil, child.wife', tostring(child.wife))

    parent.__index = nil

    child.house = 5
    child.wife = 6
    --assert(child.house,"[metatable] __newindex test: child.house: nil")
    ct.log('abel_w4',"[test__newindex] __newindex test: child.house: ".. tostring(child.house))
    ct.log('abel_w4',"[test__newindex] __newindex test: child.wife: "..tostring(child.wife))

end)


local Parent = {}

function Parent:new()
    local newParent = { house = "white house" }
    self.__index = self
    return setmetatable(newParent, self)
end

function Parent:Wife( )
    ct.log('abel_w4',"mother live in the "..self.house )
end
function Parent:Position()
    ct.log('abel_w4',"Parent live in the "..self.house)
    self:Wife()
end
parent = Parent:new()
parent:Wife()


--Inherit in a similar way
Child = Parent:new()
function Child:Position()
    local ChildHouse = self.house
    ct.log('abel_w4',"child live in the "..ChildHouse)
    self:Wife()
end

--Inherit in a similar way
Child1 = Parent:new()
function Child1:Position()
    local ChildHouse = self.house
    ct.log('abel_w4',"Child1 live in the "..ChildHouse)
    self:Wife()
end

UnitTest.Exec("abel_w4", "test_metatable_DynamicBind",  function ()
    child = Child:new()
    child1 = Child1:new()

    child:Position()

    local testArray = {}
    testArray[0] = child
    testArray[1] = child1
    for k,v in pairs(testArray)  do
        v:Position()
    end
end)

-- In Lua, check the order of a certain value: for example, the house property of child. First go to Child to check if there is a certain field. Will retrieve the meta method __index.
-- That is, when you need to access a field that does not exist in the table, the interpreter will look for a meta method called __index, if there is no meta method, then the access result is nil, otherwise this meta method will provide the final result.
    UnitTest.Exec("abel_w4", "test_metatable__index", function ()
         test1 = {param1 = 1}
         test2 = {param2 = 2}
         test3 = {param3 = 3}
    
         -- test2.__index = test1 is equivalent to:
    test2.__index = function(testTable , key)
        ct.log("abel_w4",testTable)
        ct.log("abel_w4",test3)
        ct.log("abel_w4",key)
        ct.log("abel_w4",test1[key])
        return test1[key]
    end
    setmetatable(test3 , test2)

    ct.log("abel_w4","test3.param1: "..tostring(test3.param1))
    ct.log("abel_w4","test3.param2: "..tostring(test3.param2))
    ct.log("abel_w4","test3.param3: "..tostring(test3.param3))

    -- The __index assignment here is equivalent to test2.__index = test1

     --The result printed in the comment section is:
    -- table: 0x7fe038c05440
    -- table: 0x7fe038c05440
    -- param1
    -- 1
    -- nil
    -- table: 0x7fe038c05440
    -- table: 0x7fe038c05440
    -- param2
    -- nil
    -- nil
    -- 3
end)

--The address of testTable is the same as the address of test3. It can be seen that the meta method of __index has a default parameter that is the table itself. And here setmetatable just sets the metatable to the table,
--The real query field is the field in the table pointed to by the __index meta method in the meta table. Instead of the fields in the metatable.

UnitTest.TestBlockEnd()-----------------------------------------------------------
