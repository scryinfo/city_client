---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cyz_scry.
--- DateTime: 2018/11/13 16:52
---
UnitTest.TestBlockStart()-------------------------------------------------------
local typeof = tolua.typeof
--基本测试数据准备{
--目前的测试是1000个160*160贴图的资源IO测试
local testcount = 1000  --资源加载数量
local ResPathList = {}  --资源路径
for i = 1, testcount do
    ResPathList[i] = 'TempIcon/A'..i
end

local ResPathListS = {}  --资源路径
for i = 1, testcount do
    ResPathListS[i] = 'TempIcon/A'..i
end
--基本测试数据准备}

--异步方式加载、卸载的内存测试,
--[[
    测试说明：
    1、 运行时只会使用这种方式加载
    2、 由于是异步的需要使用timer来延迟卸载
    3、 由于是异步的，所以只能用于测试资源加载的内存销毁情况，而不能测试资源加载的IO时延，
        IO时延测试放在后续同步加载的测试分组 abel_w17_load_unload_s160_time 中
--]]

--异步加载测试
local testLoadFun = function(inBundlelist, inAssertlist,type)
    for i = 1, testcount do
        panelMgr:LoadPrefab_A(ResPathList[i], type, nil,function(self, obj ,ab)
            inBundlelist[#inBundlelist +1] = ab
            inAssertlist[#inAssertlist] = obj
        end)
    end
end

UnitTest.Exec("abel_w17_load_A_sprite_s160_mem", "abel_w17_load_A_sprite_s160_mem",  function ()
    local bundlelist ={}        --存放bundle的表
    local assetlist ={}

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_sprite_s160_mem','[abel_w17_load_A_sprite_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist,ct.getType(UnityEngine.Sprite))
        collectgarbage("collect")
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_A_texture_s160_mem", "abel_w17_load_A_texture_s160_mem",  function ()
    local bundlelist ={}        --存放bundle的表
    local assetlist ={}

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_texture_s160_mem','[abel_w17_load_A_texture_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist)
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_A_unload_force_s160_mem", "abel_w17_load_A_unload_force_s160_mem",  function ()
    local bundlelist ={}        --存放bundle的表
    local assetlist ={}
    -- unloadAllLoadedObjects 方式卸载测试
    local TestUnLoadFun_force = function(reslist )
        ct.log('abel_w17_load_A_unload_force_s160_mem','[testUnLoadFun] #reslist = '..#reslist)
        for k,v in pairs(reslist ) do
            UnityEngine.AssetBundle.Unload(v,true)
            v = nil
        end
        --如果 unloadAllLoadedObjects 为true，那么 bundle 和 asset 都可以卸载掉
    end

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_unload_force_s160_mem','[abel_w17_load_A_unload_force_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist, ct.getType(UnityEngine.Sprite))
        local timer = FrameTimer.New(function()
            ct.log('abel_w17_load_A_unload_force_s160_mem','[abel_w17_load_A_unload_force_s160_mem] TestUnLoadFun_force')
            TestUnLoadFun_force(bundlelist)
            bundlelist ={}
            collectgarbage("collect")
        end, 90, 0)
        timer:Start()
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_AS_unload_No_force_s160_mem", "abel_w17_load_AS_unload_No_force_s160_mem",  function ()
    local bundlelist ={}        --存放bundle的表
    local assetlist ={}     --存放asset的表
    -- 非unloadAllLoadedObjects 方式卸载测试
    local TestUnLoadFun_No_Force = function(reslist )
        ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[TestUnLoadFun_No_Force] #reslist = '..#reslist)
        for k,v in pairs(reslist ) do
            UnityEngine.AssetBundle.Unload(v,false)
            v = nil
        end
        for k,v in pairs(assetlist) do
            UnityEngine.Resources.UnloadAsset(v)
            GameObject.DestroyImmediate(v, true)
            v = nil
        end
        assetlist = nil
    end

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[abel_w17_load_AS_unload_No_force_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist)
        local timer = FrameTimer.New(function()
            ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[abel_w17_load_AS_unload_No_force_s160_mem] TestUnLoadFun_No_Force')
            TestUnLoadFun_No_Force(bundlelist)
            bundlelist ={}
            collectgarbage("collect")
        end, 90, 0)
        timer:Start()
    end, 10, 0)
    timer0:Start()

    --测试结果
    --如果 unloadAllLoadedObjects 为true，那么 bundle 和 asset 都可以卸载掉
    --如果 unloadAllLoadedObjects 为false，那么 bundle 可以卸载，但是加载到内存的 asset 不能被清理掉
    --那么究竟是哪儿还在引用这些 asset ？
    --[[
    原因找到：
        原来是因为 panelMgr:LoadPrefab_A(ResPathList[i], ptype, nil,function(self, obj ,ab)
        ptype 为 Sprite ,传入这个类型，实际上相当于先 load 了 asset ，然后创建了引用该资源的 Sprite
        也就是说，  GameObject.DestroyImmediate(v, true) 实际上只销毁了 Sprite ，并没有销毁 asset
    --]]
end)

--同步方式加载、卸载的内存测试, 运行时不会使用这种方式加载，但是，这个测试可以用来明确加载不同尺寸的贴图的速度
--[[
    需要提供自定义的加载接口，要满足：
    1、 符合我们项目资源和包的命名约定
            1、 bundle名字为：
                1、 相对路径（相对 view 目录，开头没有'/'）中'/'转为'_'
                2、 扩展名为' .unity3d'
            2、 资源名文件名，不带路径和扩展名
    2、 加载bundle
    3、加载对应资源
    * 注意
        * 2、3步需要扩展一个单独的接口， 类似 panelMgr:LoadPrefab_S
        * 这个测试需要比对尺寸128和160的加载时间
--]]
UnitTest.Exec("abel_w17_load_S_s160_n1000_time", "abel_w17_load_S_s160_n1000_time",  function ()
    local assetlist ={}     --存放asset的表
    --异步加载测试
    local testLoadFun_S = function(reslist,type)
        ct.log('abel_w17_load_S_s160_n1000_time','[testLoadFun_S] #reslist = '..#reslist)
        for i = 1, testcount do
            --注意这里返回的值包括两个数据： asset, bundle
            reslist[#reslist+1] = resMgr:LoadRes_S(ResPathListS[i], type)
        end
    end

    --尺寸128的测试

    --尺寸160的测试
    --加载 sprite
    collectgarbage("collect")
    local t1 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n1000_time","[Sprite同步加载的时间测试]", function()
        testLoadFun_S(assetlist,ct.getType(UnityEngine.Sprite))
    end)
    ct.log('abel_w17_load_S_s160_n1000_time','1000个160大小的Sprite同步加载的时间 = '..t1)

    --卸载
    for k,v in pairs(assetlist ) do
        UnityEngine.AssetBundle.Unload(v._bunldle,true)
        v = nil
    end
    assetlist = {}
    collectgarbage("collect")

    --加载 texture
    local t2 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n1000_time","[Texture同步加载的时间测试]", function()
        testLoadFun_S(assetlist, nil)
    end)
    ct.log('abel_w17_load_S_s160_n1000_time','1000个160大小的Texture同步加载的时间 = '..t2)
    collectgarbage("collect")

    --[[
    测试结果
    pc
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Sprite同步加载的时间 = 20.255
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Texture同步加载的时间 = 19.454
        *  性能差别可以忽略不计
        *  pc 上每帧加载 33.33 / 20.255 = 1.65
    设备
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Sprite同步加载的时间 = 4.293647
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Texture同步加载的时间 = 2.265139
        *  性能差别比较明显，近1倍， 不过一般情况下，滑动滚动条时，加载3屏，一屏10个算，那么一次加载10个，那么加载时间为
        *  设备上每帧加载  33.33 / 4.293647 = 7.76
    --]]
end)

--同步下周30张Icon
UnitTest.Exec("abel_w17_load_S_s160_n30_time", "abel_w17_load_S_s160_n30_time",  function ()
    local testcount = 30
    local assetlist ={}     --存放asset的表
    --异步加载测试
    local testLoadFun_S = function(reslist,type)
        ct.log('abel_w17_load_S_s160_n30_time','[testLoadFun_S] #reslist = '..#reslist)
        for i = 1, testcount do
            --注意这里返回的值包括两个数据： asset, bundle
            reslist[#reslist+1] = resMgr:LoadRes_S(ResPathListS[i], type)
        end
    end

    --尺寸128的测试

    --尺寸160的测试
    --加载 sprite
    collectgarbage("collect")
    local t1 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n30_time","[Sprite同步加载的时间测试]", function()
        testLoadFun_S(assetlist,ct.getType(UnityEngine.Sprite))
    end)
    ct.log('abel_w17_load_S_s160_n30_time','30个160大小的Sprite同步加载的时间 = '..t1)

    --卸载
    for k,v in pairs(assetlist ) do
        UnityEngine.AssetBundle.Unload(v._bunldle,true)
        v = nil
    end
    assetlist = {}
    collectgarbage("collect")

    --加载 texture
    local t2 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n30_time","[Texture同步加载的时间测试]", function()
        testLoadFun_S(assetlist, nil)
    end)
    ct.log('abel_w17_load_S_s160_n30_time','30个160大小的Texture同步加载的时间 = '..t2)
    collectgarbage("collect")

    --[[
    测试结果
    pc
        ......
    设备
        [abel_w17_load_S_s160_n30_time]30个160大小的Sprite同步加载的时间 = 0.227158
        [abel_w17_load_S_s160_n30_time]30个160大小的Texture同步加载的时间 = 0.119937
        *  性能差别比较明显，1倍
        *  按一帧 0.03333 秒算， 同步加载 30 个 Sprite 要  0.227158/0.03333 = 6.8 , 将近7帧
        *  异步会比这个快得多
    --]]
end)

--异步加载1000个160 icon 时间测试
UnitTest.Exec("abel_w17_load_A_s160_n1000_time", "abel_w17_load_A_s160_n1000_time",  function ()
    --尺寸160的测试
    local aTester = AsyncSequenceTester:new()

    --初始化测试数据
    aTester.testcount = 1000
    aTester.loadCount = 0
    aTester.bundlelist = {}
    aTester.assertlist = {}
    aTester.startTime = 0
    aTester.ResPathList = ResPathList
    aTester.curPos = 1
    aTester.testSquence = {}

    --异步加载测试,带回调
    local testLoadFunA = function(type, testData, cb)
        for i = 1, testData.testcount do
            panelMgr:LoadPrefab_A(testData.ResPathList[i], type, testData,cb)
        end
    end

    --加载成功后的回调
    local callback = function (testData, obj , ab)
        testData.bundlelist[#testData.bundlelist +1] = ab
        testData.assertlist[#testData.assertlist] = obj
        testData.loadCount = testData.loadCount + 1
        if testData.loadCount >= testData.testcount then
            local costTime = os.clock() - testData.startTime
            ct.log('abel_w17_load_A_s160_n1000_time',testData:getCurSeq().msg ..costTime)

            --卸载

            local pos = #testData.bundlelist
            while pos > 0 do
                if testData.bundlelist[pos] ~= nil then
                    resMgr:UnloadAssetBundle(testData.bundlelist[pos].name, true)
                    --UnityEngine.AssetBundle.Unload(testData.bundlelist[pos],true)
                    table.remove(testData.bundlelist, pos)
                    pos = pos -1
                end
            end

            --testData:Nextfun()
            --collectgarbage("collect")
            --testData:excute()

            local timer = FrameTimer.New(function()
                testData:Nextfun()
                collectgarbage("collect")
                testData:excute()
            end, 90,0)
            timer:Start()
        end
    end

    aTester.testSquence[1] = { fun = testLoadFunA, type = nil, cb = callback, msg = '1000个160大小的 Texture 异步加载的时间 ='}
    aTester.testSquence[2] = { fun = testLoadFunA, type = ct.getType(UnityEngine.Sprite), cb = callback, msg = '1000个160大小的 Sprite 异步加载的时间 = '}

    --开始执行异步测试序列
    collectgarbage("collect")
    aTester:excute()
    --尺寸128的测试
    --[[
    测试结果
    pc
        [abel_w17_load_A_s160_n1000_time]1000个160大小的 Texture 异步加载的时间 =2.2260000000001
        [abel_w17_load_A_s160_n1000_time]1000个160大小的 Sprite 异步加载的时间 = 2.3319999999999
        *  性能差别比不大, 平均每帧可以加载 33.33/2.332 = 14.29 个
    设备
        [abel_w17_load_A_s160_n1000_time]1000个160大小的 Texture 异步加载的时间 =6.757779
        [abel_w17_load_A_s160_n1000_time]1000个160大小的 Sprite 异步加载的时间 = 6.006067
        *  设备上 Sprite 比 Texture 加载的时间还短
            * 这个结论与同步加载的结论一致？
        * 平均每帧可以加载 33.33/6.006067 = 5.555 个（texture 33.33/6.757779 = 4.932 个 ）
        * 比对同步加载
            [abel_w17_load_S_s160_n1000_time]1000个160大小的Texture同步加载的时间 = 2.265139
            [abel_w17_load_S_s160_n1000_time]1000个160大小的Sprite同步加载的时间 = 4.293647
            * Sprite异步加载总的耗时与同步加载差不多；texture 同步加载时间会少不少
            * 同步加载期间会导致程序卡顿
    --]]
end)

--测试 Instantiate 及对应 destory 的性能开销
UnitTest.Exec("abel_w17_Instantiate_destory_s160_n1000", "abel_w17_Instantiate_destory_s160_n1000",  function ()
    --local resTexture = resMgr:LoadRes_S(ResPathListS[1], LuaHelper.GetType("UnityEngine.Texture2D"))
    --local resTexture = resMgr:LoadRes_S(ResPathListS[1], LuaHelper.GetType("UnityEngine_Texture2DWrap"))
    local tp = ct.getType(UnityEngine.Texture2D)
    local tp1 = ct.getType(UnityEngine.Sprite)

    local resTexture = resMgr:LoadRes_S(ResPathListS[1], ct.getType(UnityEngine.Texture2D))
    --[[
    --这里设置贴图资源为 Readable ,否则 Instantiate 会失败，提示为 Instantiating a non-readable texture is not allowed!
    --参考 https://www.cnblogs.com/weigx/p/7300586.html
    --]]
    --resTexture._asset:Apply(true,true)
    local resSprite = resMgr:LoadRes_S(ResPathListS[1], ct.getType(UnityEngine.Sprite))
    local insList_texture = {}
    local insList_sprite = {}

    ct.log('abel_w17_Instantiate_destory_s160_n1000','testcount = '..testcount)

    --实例化1000张Sprite
    local textureIns = UnitTest.PerformanceTest("abel_w17_Instantiate_destory_s160_n1000","[1000 张 Sprite Instantiate 的时间]", function()
        for i = 1, testcount do
            insList_sprite[#insList_sprite+1] = UnityEngine.GameObject.Instantiate(resSprite._asset);
        end
    end)

    --销毁1000张Sprete的实例
    local textureIns = UnitTest.PerformanceTest("abel_w17_Instantiate_destory_s160_n1000","[1000 张 Sprite 销毁 的时间]", function()
        for i, v in pairs(insList_sprite) do
            GameObject.DestroyImmediate(v, true)
        end
        insList_sprite = {}
    end)

    --[[
    测试结果
    [abel_w17_Instantiate_destory_s160_n1000][1000 张 Sprite Instantiate 的时间]        执行时间:     0.014999999999873  一帧 Instantiate 2.22 个
        * 这个数据还只是简单数据的实例化，复杂数据可能会更耗时，所以 Instantiate 一定要慎用
    [abel_w17_Instantiate_destory_s160_n1000][1000 张 Sprite 销毁 的时间]               执行时间:     0.0029999999997017 一帧销毁 11.11 个
    --]]
end)

--滚动条同步加载prefab资源对比测试
UnitTest.Exec("abel_w17_load_s128_n400_Sync", "abel_w17_load_s128_n400_Sync",  function ()
    --测试数据准备{
    local testcount = 10
    local ResPathList = {}
    for i = 1, testcount do
        ResPathList[i] = 'View/TempIcon/A'..i
    end
    --测试数据准备}
    local exectime1 = UnitTest.PerformanceTest("abel_w17_load_s128_n400_Sync","[同步加载400个尺寸为128的 Icon: Resource.Load]", function()
        local prefab = UnityEngine.Resources.Load( 'View/TempIcon/Image');

        for i = 1, testcount do
            --加载 prefab 资源
            local resLoad = UnityEngine.Resources.Load(ResPathList[i])
            local go = UnityEngine.GameObject.Instantiate(resLoad)
            --go.transform:GetComponent("Image").sprite = resLoad
            local xxx = 0
        end
    end)

    local exectime1 = UnitTest.PerformanceTest("abel_w17_load_s128_n400_Sync","[同步加载400个尺寸为128的 Icon: AssetBundle.Load]", function()

    end)

    ct.OpenCtrl('TestSliderCtrl',ResPathList)
end)

---AOI测试---------------------------------------------------------------------------------------------------------------------------
--AOI异步加载时间测试
UnitTest.Exec("abel_w17_Aoi_load_building_ASync", "abel_w17_Aoi_load_building_ASync",  function ()
    local aTester = AsyncSequenceTester:new()
    --初始化测试数据
    aTester.testcount = 1
    aTester.loadCount = 0
    aTester.bundlelist = {}
    aTester.assertlist = {}
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}

    aTester.resetData = function(self)
        self.bundlelist = {}
        self.assertlist = {}
        self.startTime = 0
    end

    --异步加载测试,带回调
    local testLoadFunA = function(tester, curSeq)
        for i = 1, tester.testcount do
            panelMgr:LoadPrefab_A(curSeq.path, curSeq.type, tester,curSeq.cb)
        end
    end

    local unloadFun = function(testData)
        for i, v in pairs(testData.testSquence) do
            if v.bundle ~= nil then
                resMgr:UnloadAssetBundle(v.bundle.name, true)
            end
        end
        local costTime = os.clock() - testData.startTime
        ct.log('abel_w17_Aoi_load_building_ASync',testData:getCurSeq().msg ..costTime)
    end

    --加载成功后的回调
    local callback = function (testData, obj , ab)
        testData.testSquence[testData.curPos].bundle = ab
        testData.testSquence[testData.curPos].asset = obj
        testData.loadCount = testData.loadCount + 1
        if testData.loadCount >= testData.testcount then
            local costTime = os.clock() - testData.startTime
            ct.log('abel_w17_Aoi_load_building_ASync',testData:getCurSeq().msg ..costTime)

            --卸载
            --local pos = #testData.bundlelist
            --while pos > 0 do
            --    if testData.bundlelist[pos] ~= nil then
            --        resMgr:UnloadAssetBundle(testData.bundlelist[pos].name, true)
            --        table.remove(testData.bundlelist, pos)
            --        pos = pos -1
            --    end
            --end

            local timer = FrameTimer.New(function()
                testData:Nextfun()
                collectgarbage("collect")
                testData:excute()
            end, 15,0)
            timer:Start()
        end
    end

    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/CentralBuilding_Build',msg = 'CentralBuilding_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Factory_3x3_Build',msg = 'Factory_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/MaterialBuilding_3x3_Build',msg = 'MaterialBuilding_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Park_3x3_Build',msg = 'Park_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/SuperMarket_3x3_Build',msg = 'SuperMarket_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Techo_3x3_Build',msg = 'Techo_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/WareHouse_3x3_Build',msg = 'WareHouse_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = unloadFun, type = nil, cb = nil, path = ' ',msg = 'unloadFun 卸载所有建筑的耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Museum',msg = 'Museum 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Park_3x3',msg = 'Park_3x3 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Stadium',msg = 'Stadium 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/TechnologyBuilding_3x3',msg = 'TechnologyBuilding_3x3 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/UnderConstruction_3x3_03',msg = 'UnderConstruction_3x3_03 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/University',msg = 'University 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Airport',msg = 'Airport 异步加载的时间 ='}
    
    --开始执行异步测试序列
    collectgarbage("collect")
    aTester:excute()
    --[[
    测试结果
    --加载时间
        PC
            [abel_w17_Aoi_load_building_ASync]Factory_3x3_Build 异步加载的时间 =0.372      --第一个的时间貌似都偏长
            [abel_w17_Aoi_load_building_ASync]CentralBuilding_Build 异步加载的时间 =0.065000000000001
            [abel_w17_Aoi_load_building_ASync]MaterialBuilding_3x3_Build 异步加载的时间 =0.096999999999753
            [abel_w17_Aoi_load_building_ASync]Park_3x3_Build 异步加载的时间 =0.065999999999804
            [abel_w17_Aoi_load_building_ASync]SuperMarket_3x3_Build 异步加载的时间 =0.095999999999549
            [abel_w17_Aoi_load_building_ASync]Techo_3x3_Build 异步加载的时间 =0.097999999999956
            [abel_w17_Aoi_load_building_ASync]WareHouse_3x3_Build 异步加载的时间 =0.096999999999753
        设备
            [abel_w17_Aoi_load_building_ASync]Factory_3x3_Build 异步加载的时间 =0.515782   --第一个的时间貌似都偏长
            [abel_w17_Aoi_load_building_ASync]CentralBuilding_Build 异步加载的时间 =0.330709
            [abel_w17_Aoi_load_building_ASync]MaterialBuilding_3x3_Build 异步加载的时间 =0.308198
            [abel_w17_Aoi_load_building_ASync]Park_3x3_Build 异步加载的时间 =0.232529
            [abel_w17_Aoi_load_building_ASync]SuperMarket_3x3_Build 异步加载的时间 =0.307951
            [abel_w17_Aoi_load_building_ASync]Techo_3x3_Build 异步加载的时间 =0.293312
            [abel_w17_Aoi_load_building_ASync]WareHouse_3x3_Build 异步加载的时间 =0.341899
            加载一个建筑大概 0.330709/0.0333333333333333 = 9.92127000000001 左右， 假设建筑类型10个，加载所有建筑要要   0.33*10 = 3.3秒
     --内存占用
        PC
            texture momory 32M
            Total Allocated
                打开测试分组 249帧 138.5 M
                关闭测试分组 249帧 123.8 M
                测试分配的内存 138.5 - 123.8 = 14.7 M
        设备
            texture memory 	7.7M
                * 7个建筑平均每个1.1M
            Total Allocated
                打开测试分组 122 帧 36.7 M
                关闭测试分组 122 帧 27.7 M
                测试分配的内存 36.7 - 27.7 = 9 M
    --卸载
        PC
            [abel_w17_Aoi_load_building_ASync]unloadFun 卸载所有建筑的耗时 =0.020000000000437
       设备
            [abel_w17_Aoi_load_building_ASync]unloadFun 卸载所有建筑的耗时 =0.066083000000001
            * 0.0333333333333333秒一帧，那么2帧可以完全卸载
    --结论
        在设备上所有建筑加载到内存也就 8、9M，内存负担不大；而建筑加载的时间成本很高，单个平均在 0.3 秒左右，可以肯定地说是不能在运行时加载的。
        所以建筑的加载策略应该是根据城市来预加载，并常驻内存； 卸载压力很小，可以不用考虑
    --]]
end)

--AOI 9屏建筑实例化时间及内存测试
UnitTest.Exec("abel_w17_Aoi_Instantiate_9Grid", "abel_w17_Aoi_Instantiate_9Grid",  function ()
    local aTester = AsyncSequenceTester:new()
    --初始化测试数据
    aTester.testcount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.instances = {}
    aTester.resetData = function(self)
        self.startTime = 0
    end
    --数据准备
    local ResPathListS = {}
    ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Park_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Techo_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Build'

    aTester.ResPathList = ResPathListS
    --数据准备

    local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            local loadDataInfo =  resMgr:LoadRes_S(tester.ResPathList[i], ct.getType(UnityEngine.GameObject));
            tester.loadedBundles[#tester.loadedBundles+1] = loadDataInfo._bunldle
            tester.loadedAssets[#tester.loadedAssets+1] = loadDataInfo._asset
        end
        tester:getCurSeq().postfun(tester)
    end

    --实例化方法
    local InstantiateFun = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[InstantiateFun]')
        local curSeq = tester:getCurSeq()
        for i = 1, #aTester.loadedAssets do
            for j = 1, curSeq._inscount do
                tester.instances[#tester.instances+1] = UnityEngine.GameObject.Instantiate(aTester.loadedAssets[i])
            end
        end
        curSeq.postfun(tester)
    end

    local destroyInstances = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[destroyInstances]')
        for i, v in pairs(tester.instances) do
            GameObject.DestroyImmediate(v, true)
        end
        tester.instances = {}
        collectgarbage("collect")
        tester:getCurSeq().postfun(tester)
    end

    local unloadFun = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[unloadFun]')
        for i, v in pairs(tester.loadedBundles) do
            if v ~= nil then
                UnityEngine.AssetBundle.Unload(v,true)
            end
        end
        for i, v in pairs(tester.loadedAssets) do
            if v ~= nil then
                UnityEngine.Resources.UnloadAsset(v)
            end
        end
        tester.loadedBundles = {}
        tester.loadedAssets = {}
        tester:getCurSeq().postfun(tester)
    end

    --加载成功后的回调
    local callback = function (tester)
        local costTime = os.clock() - tester.startTime
        ct.log('abel_w17_Aoi_Instantiate_9Grid',tester:getCurSeq().msg ..costTime)
        local timer = FrameTimer.New(function()
            tester:Nextfun()
            collectgarbage("collect")
            tester:excute()
        end, 5,0)
        timer:Start()
    end

    aTester.testSquence[#aTester.testSquence+1] = { fun = LoadTestRes, _inscount = 6, prefun = nil, postfun = callback, msg = '加载所有建筑资源耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = InstantiateFun, _inscount = 507, prefun = aTester.resetData, postfun = callback, msg = '1屏450个实例，9屏4050实例的实例化耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = destroyInstances, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '9屏4050实例的销毁耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = InstantiateFun, _inscount = 248, prefun = aTester.resetData, postfun = callback, msg = '1屏220个实例，9屏1980实例的实例化耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = destroyInstances, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '9屏1980实例的销毁耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = unloadFun, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '所有(一共'..#aTester.ResPathList..'个)建筑卸载的时间 ='}

    --开始执行异步测试序列
    collectgarbage("collect")
    aTester:excute()
    --[[
    测试结果
    --实例化时间
        PC
            [abel_w17_Aoi_Instantiate_9Grid]1屏220个实例，9屏1980实例的实例化耗时 =4.391
            [abel_w17_Aoi_Instantiate_9Grid]9屏1980实例的销毁耗时 =0.026999999999987
            [abel_w17_Aoi_Instantiate_9Grid]1屏450个实例，9屏4050实例的实例化耗时 =4.269
            [abel_w17_Aoi_Instantiate_9Grid]9屏4050实例的销毁耗时 =0.057999999999993
            [abel_w17_Aoi_Instantiate_9Grid]所有(一共7个)建筑卸载的时间 =0.0010000000000048
        设备
            [abel_w17_Aoi_Instantiate_9Grid]加载所有建筑资源耗时 =0.698422
            [abel_w17_Aoi_Instantiate_9Grid]1屏220个实例，9屏1980实例的实例化耗时 =13.512051
            [abel_w17_Aoi_Instantiate_9Grid]9屏1980实例的销毁耗时 =0.33568
            [abel_w17_Aoi_Instantiate_9Grid]1屏450个实例，9屏4050实例的实例化耗时 =24.404046
            [abel_w17_Aoi_Instantiate_9Grid]9屏4050实例的销毁耗时 =0.57482
            [abel_w17_Aoi_Instantiate_9Grid]所有(一共6个)建筑卸载的时间 =0.054358000000001
     --内存占用
        PC
            texture memory
                打开测试分组
                    第1帧     21.1 M
                    第4帧     32.9 M
            Total Allocated
                打开测试分组
                    第1帧     123.6 M
                    第12帧    294.0 M
                    第26帧    274.6 M
                    第43帧    418.2 M
                    第47帧之后    370.2 M
                关闭测试分组 249帧 123.8 M
                测试分配的内存 138.5 - 123.8 = 14.7 M
        设备
           texture memory
                打开测试分组
                    第1帧     21.1 M
                    第4帧     32.9 M
            Total Allocated
                打开测试分组
                    LoadTestRes 结束    30.9 M
                    InstantiateFun 330 结束    55,1 M
                    destroyInstances 结束  41.4 M
                    InstantiateFun 670 结束 82.3 M
                    destroyInstances 结束 52.5 M
                    unloadFun 结束    43.5 M
                    * 剩余 43.5 M
                        Not Saved
                            RenderTexture 26.7
                                TempBuffer 1 1080*2160 17.8 M
                                ImageEffects Temp 8.9 M
                        Other
                            GfxDevice
                                GfxDeviceClient 8 M
                关闭测试分组 122 帧 27.7 M
                测试分配的内存 36.7 - 27.7 = 9 M
    --卸载
        PC
            [abel_w17_Aoi_load_building_ASync]unloadFun 卸载所有建筑的耗时 =0.020000000000437
       设备
            [abel_w17_Aoi_load_building_ASync]unloadFun 卸载所有建筑的耗时 =0.066083000000001
            * 0.0333333333333333秒一帧，那么2帧可以完全卸载
    --结论
        在设备上所有建筑加载到内存也就 8、9M，内存负担不大；而建筑加载的时间成本很高，单个平均在 0.3 秒左右，可以肯定地说是不能在运行时加载的。
        所以建筑的加载策略应该是根据城市来预加载，并常驻内存； 卸载压力很小，可以不用考虑

        1秒可以实例化 4050/24.404046 = 165.9560877733143
        1帧实例化 165.9560877733143/30 = 5.53186959244381
        1个实例化需要时间 24.404046/4050 = 0.0060256903703704 秒
        1屏实例化需要时间 450 * 0.0060256903703704 = 2.71156066666668
    --]]
end)

--AOI 9屏4050个对象实例化并放到对象池帧速测试
--[[
1屏实例化需要时间 450 * 0.0060256903703704 = 2.71156066666668秒， 那么就按一屏算
8 种建筑每个实例化 450/8 = 56.25 个 aTester.testcount = 57
    1帧实例化1个
    1帧实例化2个
    1帧实例化3个
    1帧实例化4个
    1帧实例化5个
    1帧实例化6个
    1帧实例化7个
    1帧实例化8个
    1帧实例化9个
    1帧实例化10个
-]]
UnitTest.Exec("abel_w17_Aoi_Inst_9Grid_frameRate", "abel_w17_Aoi_Inst_9Grid_frameRate",  function ()
    local aTester = AsyncSequenceTester:new()
    AsyncSequenceTester.recordTester(aTester)
    --初始化测试数据
    --aTester.testcount = 600
    --aTester.testcount = 2
    aTester.instancedCount = 1
    aTester.resLoadedCount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.loadedAssetsNextIdx = 1
    aTester.instances = {}
    aTester._timer = nil
    aTester._msgs = ''
    aTester.resetData = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
        tester.instancedCount = 1
    end
    --数据准备
    local ResPathListS = {}
    ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Park_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Techo_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Root'

    aTester.ResPathList = ResPathListS
    --数据准备

    local LoadedCb = function(tester, as, ab)
        tester.loadedBundles[#tester.loadedBundles+1] = ab
        tester.loadedAssets[#tester.loadedAssets+1] = as
        tester.resLoadedCount = tester.resLoadedCount + 1
        if tester.resLoadedCount > #tester.ResPathList then
            tester:getCurSeq().postfun(tester)
        end
    end
    --异步加载测试,带回调
    local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            panelMgr:LoadPrefab_A(tester.ResPathList[i], nil, tester,LoadedCb)
        end
    end

    --实例化方法
    local InstantiateFun = function()
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()
        --超过
        if tester.instancedCount >   tester.testcount then
            tester._timer:Stop()
            return curSeq.postfun(tester)
        end

        for j = 1, curSeq._inscount do
            tester.instances[#tester.instances+1] = UnityEngine.GameObject.Instantiate(aTester.loadedAssets[aTester.loadedAssetsNextIdx])
            aTester.loadedAssetsNextIdx = aTester.loadedAssetsNextIdx +1
            tester.instancedCount = tester.instancedCount + 1
            --循环从资源列表中抽取要实例化的资源
            if aTester.loadedAssetsNextIdx > #aTester.loadedAssets then
                aTester.loadedAssetsNextIdx = 1
            end
        end
    end

    aTester._timer = FrameTimer.New(function()
        InstantiateFun()
    end, 1,1)

    local Insfun_Loop = function(tester)
        tester._timer:Start()
    end

    local destroyInstances = function(tester)
        for i, v in pairs(tester.instances) do
            GameObject.DestroyImmediate(v, true)
        end
        tester.instances = {}
        collectgarbage("collect")
        tester:getCurSeq().postfun(tester)
    end

    local unloadFun = function(tester)
        --ct.log('abel_w17_Aoi_Inst_9Grid_frameRate','[unloadFun]')
        for i, v in pairs(tester.loadedBundles) do
            if v ~= nil then
                UnityEngine.AssetBundle.Unload(v,true)
            end
        end
        for i, v in pairs(tester.loadedAssets) do
            if v ~= nil then
                UnityEngine.Resources.UnloadAsset(v)
            end
        end
        tester.loadedBundles = {}
        tester.loadedAssets = {}
        tester:getCurSeq().postfun(tester)
    end

    local finishedfun = function(tester)
        ct.log('abel_w17_Aoi_Inst_9Grid_frameRate',tester._msgs)
    end
    --加载成功后的回调
    local callback = function (tester)
        local nextDelay = tester:getCurSeq()._nextTestDelay
        local costTime = os.clock() - tester.startTime
        collectgarbage("collect")
        tester._msgs = tester._msgs..'\n'..tester:getCurSeq().msg ..costTime
        local timer = FrameTimer.New(function()
            tester:Nextfun()
            tester:excute()
        end, nextDelay,0)
        timer:Start()
    end

    aTester.testcount = 4050
    aTester.testSquence[#aTester.testSquence+1] = { fun = LoadTestRes, _inscount = 1, _nextTestDelay = 60, prefun = nil, postfun = callback, msg = '加载所有建筑资源耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 1, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 1 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 2, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 2 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 3, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 3 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 4, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 4 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 5, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 5 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 6, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 6 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 7, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 7 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 8, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 8 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 9, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 9 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 10, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 10 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 15, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 15 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 20, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 20 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 30, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 30 次实例化, '..aTester.testcount..'个实例耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 40, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 40 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 80, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 80 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = Insfun_Loop, _inscount = 160, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 160 次实例化, '..aTester.testcount..'个实例耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = destroyInstances, _inscount = 0, _nextTestDelay = 30, prefun = aTester.resetData, postfun = callback, msg = aTester.testcount.'个实例的销毁耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = unloadFun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = '所有(一共'..#aTester.ResPathList..'个)建筑卸载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = finishedfun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = ''}

    --开始执行异步测试序列
    collectgarbage("collect")
    aTester:excute()
    --[[
    cpu
        DirectorUpdateAnimationBegin    39.6%
        DirectorUpdateAnimationEnd      30.2%
        * 去掉所有建筑的 Animator ，没有固定的GC掉帧了
            500个实例
                稳定在 30 帧，没有帧速波动 每帧执行 40 次实例化, 500个实例
            1500个实例
                稳定在 30 帧，没有帧速波动 每帧执行 40 次实例化, 1500个实例耗时 =1.464776
            4050个实例
                一开始稳定在 30 帧， 一段时间之后持续 22~30之间波动，没有帧速波动  每帧执行 40 次实例化, 4050个实例耗时 =5.059065
                                                                                   每帧执行 40 次实例化, 4050个实例耗时 =5.251131
                                     * unity profile 更新时，会在 22~30之间波动 ,否则稳定在 30 帧
                * 也就是说 4050 个实例实际上是可以支撑下来的，只不过要限制实例中 Animator 中的数量（带Animator组件的实例超过500就会出现高频度的GC，导致帧数波动剧烈）
                * 最新测试
                    --稳定在 30 帧 每帧执行 40 次实例化, 4050个实例耗时 =2.799826
         * 上述测试是在 荣耀9
         * 小米5X 即便打开 unity profile 采集数据的情况下， 稳定在 29-30 帧
         * Vivo X20A  稳定在 29-30 帧
         * Oppo R11t
    内存
       4050个实例 设备上内存 66.3M
       * 可以常驻内存
    测试结果
        500个实例
            设备上 30 帧    每帧执行 40 次实例化, 500个实例耗时 =0.922895
        600个实例
            设备上 30 帧 每帧执行 2 次实例化, 600个实例耗时 =14.984493
            设备上 30 帧 每帧执行 2 次实例化, 600个实例耗时 =15.828577
            设备上 30 帧 每帧执行 3 次实例化, 600个实例耗时 =9.766479
            设备上 30 帧 每帧执行 4 次实例化, 600个实例耗时 =7.621891
            设备上 30 帧 每帧执行 5 次实例化, 600个实例耗时 =5.989155
            设备上 30 帧 每帧执行 6 次实例化, 600个实例耗时 =5.25467
            设备上 30 帧 每帧执行 10 次实例化, 600个实例耗时 =3.38418
                * 期间帧速会偶尔掉到 20多帧
            设备上 30 帧 每帧执行 15 次实例化, 600个实例耗时 =2.309575
            设备上 30 帧 每帧执行 20 次实例化, 600个实例耗时 =1.870934
                * 期间帧速有抖动
            设备上 30 帧    每帧执行 40 次实例化, 600个实例耗时 =1.157611
                            每帧执行 40 次实例化, 600个实例耗时 =1.179974
                            每帧执行 40 次实例化, 600个实例耗时 =1.188734
                * 帧速有波动 15~20~30 ， 卡顿不明显
                * 如果是release版应该就更加不明显了
                            每帧执行 40 次实例化, 600个实例耗时 =0.931607
                            波动 18~30 帧 卡顿不明显
        1000个实例
            设备上 22-30帧浮动（一直，GC导致） 每帧执行 40 次实例化, 1000个实例耗时 =1.768171
        设备上 30 帧 每帧执行 80 次实例化, 600个实例耗时 =0.906708
            * 期间帧速有抖动明显 12~15~30 区间浮动
        设备上 22-30 帧 每帧执行 2 次实例化, 800个实例耗时 =27.511312
            GC导致帧速波动
        设备上 26 帧 每帧执行 3 次实例化, 1000个实例耗时 =14.984493
    --]]
end)

--建筑Aoi更新测试
--[[
测试条件
    1屏450个，最多一次更新3屏
--]]
UnitTest.Exec("abel_w17_Aoi_Relocate_3Grid_frameRate", "abel_w17_Aoi_Relocate_3Grid_frameRate",  function ()
    local aTester = AsyncSequenceTester:new()
    AsyncSequenceTester.recordTester(aTester)
    --初始化测试数据
    --aTester.testcount = 600
    --aTester.testcount = 2
    aTester.instancedCount = 1
    aTester.instancedPoolCount = 1
    aTester.resLoadedCount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.loadedAssetsNextIdx = 1
    aTester.instances = {}      --使用中的实例
    aTester.defaultInstancePools = {}   --对象池，闲置的实例
    aTester._timer = nil
    aTester._msgs = ''
    aTester.resetData = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
        tester.instancedCount = 1
    end
    --数据准备
    local ResPathListS = {}
    ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Park_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Techo_1x1_Root'
    ResPathListS[#ResPathListS+1] = 'Build/WareHouse_1x1_Root'

    aTester.CountEachType = math.ceil(aTester.testcount / #ResPathListS)
    aTester.ResPathList = ResPathListS
    --数据准备

    local LoadedCb = function(tester, as, ab)
        local pathName = string.gsub(tester.loadedBundles.name)
        tester.loadedBundles[ab.name] = ab
        tester.loadedAssets[as.name] = as
        tester.resLoadedCount = tester.resLoadedCount + 1
        if tester.resLoadedCount > #tester.ResPathList then
            tester:getCurSeq().postfun(tester)
        end
    end
    --异步加载测试,带回调
    local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            panelMgr:LoadPrefab_A(tester.ResPathList[i], nil, tester,LoadedCb)
        end
    end

    --往默认对象池中添加指定类型和数量的对象
    local extendInstancePool = function(pools, typeid, count)
        local tester = AsyncSequenceTester.Tester()
        for i = 1, count do
            pools[typeid][#pools[typeid]+1] = UnityEngine.GameObject.Instantiate(tester.loadedAssets[typeid])
        end
    end

    local getPoolSize = function(pools, typeid)
        if pools[typeid] == nil then
            return 0
        else
            return  #pools[typeid]
        end
    end

    --从默认对象池中获取特定类型实例，没有的话并且 allocate == true ，一次性实例化 40 个
    local getInstance = function(pools, typeid, allocate)
        local validInstance = nil
        local outPool = pools[typeid]
        validInstance = outPool[#outPool]
        if allocate ~= nil and allocate == true then
            --实例化
            if validInstance == nil then
                extendInstancePool(pools, typeid, 40 ) --一帧实例化40个不会影响性能
            end
        end
        --从对象池中移除该实例(否则会有多个对象池同时使用一个实例，是不对的)
        validInstance = outPool[#outPool]
        if outPool[#outPool] ~= nil then
            outPool[#outPool] = nil
        end
        return validInstance
    end
    --把实例放回对象池
    local instanceToPools = function(pools, instance)
        local typeid = instance.name
        pools[typeid][#pools[typeid]+1] = instance --注意这里没有进行类型检查，使用的时候需要用户自己保证类型正确
    end

    --创建默认对象池
    local DefaultInsPoolsSetup = function()
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()


        local pollsize = getPoolSize(tester.defaultInstancePools, tester.loadedAssets[tester.loadedAssetsNextIdx])
        if pollsize >= tester.CountEachType then --当每种类型的资源实例数量大于限定的数量后，开始另一种资源类型的实例化
            tester.loadedAssetsNextIdx = tester.loadedAssetsNextIdx + 1
            --超过
            if tester.loadedAssetsNextIdx > #tester.ResPathList then --loadedAssetsNextIdx 大于ResPathList资源类型数量，说明 所有资源类型的对象池都建立好了
                tester._timer:Stop()
                return curSeq.postfun(tester)
            end
        end
        --对象池创建，按资源路径分别建立对象池； 一次只创建 curSeq._inscount 个实例(每帧40个可以保证不卡)
        extendInstancePool(tester.defaultInstancePools,tester.ResPathList[tester.loadedAssetsNextIdx],curSeq._inscount)
    end

    aTester._timer = FrameTimer.New(function()
        DefaultInsPoolsSetup()
    end, 1,1)

    local DefaultInsPoolsSetup = function(tester)
        tester._timer:Start()
    end

    local builddata = { uuid = 'xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx',typeid = '',position={x=0,y=0 }}
    --建筑重定位测试-----------------------------------------------------------
    --目前使用25屏作为整个游戏地图来测试------------------------------------{
    --[[
        一屏450相当于 21*21=441个格子
        25屏相当于 (21*5)^2 = 11025 格单位， 长宽为 105单位
    --]]
    aTester.gridsOneBlock = 21 --1屏的横纵坐标跨度
    aTester.data_25Screen = (aTester.gridsOneBlock * 5)^2  --11025
    aTester._buildingdata = {}
    local gridsFiveBlocks = aTester.gridsOneBlock * 5 --全局地图宽度

    --这里相当于约定 _buildingdata 使用的是 gridid 作为索引
    for i = 1, gridsFiveBlocks do
        for j = 1, gridsFiveBlocks do
            local gridId = i + (j-1) * gridsFiveBlocks
            aTester._buildingdata[gridId] = {
                                            uuid = 'xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx',
                                            typeid = ResPathListS[math.random(1, #ResPathListS)],
                                            position=
                                            {
                                                 x = i ,
                                                 y = j
                                            }
            }
        end
    end
    local buildingCount = #aTester._buildingdata --看看是否是预期的数量 11025
    --25屏数据------------------------------------}

    --9屏Aoi
    aTester.relocateStartPos = 1
    aTester.relocateTestExcuteCount = 60 --总的执行 relocate 的批次
    aTester.relocateTestExcutePos = 1 --当前执行的批次
    aTester.relocateTestCountEveryExcute = 1350
    aTester.interval = 1 --每次测试的间隔帧

    local RelocateResetfun = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
        tester.relocateStartPos = tester.relocateStartPos + aTester.relocateTestCountEveryExcute
        if tester.relocateStartPos >  tester.testcount then
        tester.relocateStartPos = 1
        end
    end

    aTester.ScreenBlockSizeWorld = {x = 5, y = 5}   --整个地图aoi分块数， 一个单位相当于 1 屏， 目前是横竖各5屏，每屏21*21个建筑单位
    aTester.AoiScreenBlockSize = {x = 3, y = 3}         --真正要实例化的屏幕数据, 形成的矩形区域
    aTester.AoiScreenBlocks = {}    --实际Aoi的分块
    aTester.BuildingsInAoi = {}    --分块中的建筑
    aTester.AoiScreenBlocksNewIn = {}    --新增的分块
    aTester.AoiScreenBlocksOut = {}    --超出9屏的分块
    aTester.BuildingsOutAoi = {}    --超出9屏的分块，放入临时回收池 AoiGridsOut
    --注： 新增块中的建筑从超出反馈的块中获取，如果没有，就实例化

    --根据aoi中心，获取九屏索引数据
    local aoi_get9ScreenBlock = function(tester, aoiCenterScreenPos)
        local aoiRect = { --aoiRect取值范围在是(1,1)-(5,5)之间
        lu = {x = aoiCenterScreenPos.x -1, y = aoiCenterScreenPos.x -1}, --左上角
        rb = {x = aoiCenterScreenPos.x +1, y = aoiCenterScreenPos.x +1}  --右下角
        }
        local AoiScreenBlocksNewIn = {}
        --取出所有块的id（所有9屏id）
        for x = aoiRect.lu.x, aoiRect.rb.x do
            for y = aoiRect.lu.y, aoiRect.rb.y do
                local id_1D = x + (y-1)*tester.ScreenBlockSizeWorld.x --因为lua中数组第一个元素的索引为1，所以这里要保证id从1开始, x 不需要 -1 就可以保证
                newAoiScreenBlockArea[id_1D] = id_1D --暂时key和value都是分块id
            end
        end
        return newAoiScreenBlockArea
    end

    --比对新旧Aoi区域，超出范围的，放到 AoiScreenBlocksOut ，作为新进入范围的区块放入 AoiScreenBlocksNewIn
    local filterAoiBlocks = function(tester)
        for k,v in pairs(tester.AoiScreenBlocks) do
            if v ~= nil then
                if tester.AoiScreenBlocksNewIn[v] == nil then --原Aoi范围内有，新aoi区域中没有的块，放入 AoiScreenBlocksOut ，后边单独处理
                    tester.AoiScreenBlocksOut[#tester.AoiScreenBlocksOut+1] = v
                    tester.AoiScreenBlocks[k] = nil
                else --都有的，从新的区域中剔除掉，newAoiScreenBlockArea剩下的就是新进入范围的块
                    tester.AoiScreenBlocksNewIn[v] = nil
                end
            end
        end
    end

    --[[
        此时，  tester.AoiScreenBlocks 中只有新旧aoi数据中的交集， 超出范围的都回收到了 AoiScreenBlocksOut ， newAoiScreenBlockArea 仅有新进入范围的部分
        后续操作只需要从 AoiScreenBlocksOut（作为对象池 ）提取 newAoiScreenBlockArea 需要的建筑类型并更新位置即可，如果 newAoiScreenBlockArea 没有，
        那么再实例化（这样要实例化的就不多了）
    --]]
    local BlockID2Pos = function(tester, blockid)
        return {
            x=math.fmod( blockid, tester.ScreenBlockSizeWorld.x ),  --x 取余得x坐标
            y=math.modf( blockid, tester.ScreenBlockSizeWorld.x )+1   --y 取整得y坐标, 加1表示从 1开始计算
        }
    end

    local BlockPos2GridPos = function(tester, blockPos)
        return { --这里是从(0,0)开始的
            x = (blockPos.x -1) * tester.gridsOneBlock,
            y = (blockPos.y -1) * tester.gridsOneBlock
        }
    end

    local BlockID2GridPos = function(tester,blockid)
        --1维数组升2维，注意：这里仅仅是针对 block 分块而言，目前每个block对应 1 屏
        local blockPos = BlockID2Pos(tester, blockid)
        return BlockPos2GridPos(tester, blockPos)
    end
    local gridsOutProcessing = function(tester)
        for k, v in pairs(tester.AoiScreenBlocksOut) do
            local gridStartPos = BlockID2GridPos(tester, v)
            --根据block位置计算其中所有grid的索引
            for i = 1, tester.gridsOneBlock do
                for j = 1, tester.gridsOneBlock do
                    local gridId = (gridStartPos.x + j ) + ((gridStartPos.y + i -1) * tester.gridsOneBlock * 5) --gridsFiveBlocks全局地图宽度
                    local outinstance = tester.BuildingsInAoi[gridId]
                    tester.BuildingsInAoi[gridId] = nil
                    instanceToPools(tester.BuildingsOutAoi, outinstance) --放入激活的实例表中
                end
            end
            tester.AoiScreenBlocks[k] = nil
        end
    end

    --第一次aoi计算， AoiScreenBlocks 为空, 从 aTester._buildingdata 中取出范围内的建筑数据
    --注意， 一个ScreenBlocks 跨度为横纵坐标为: gridsOneBlock = 21 --1屏的横纵坐标跨度
    --初步的算法是 把 newAoiScreenBlockArea block id 升维转成 grid 位置， 然后再取block中所有grid对应的 builddata ,
    --根据 builddata.typeid 从 defaultInstancePools 取出对象，并使用 builddata.position 设置该对象位置
    --后边看看有没有不需要升维的算法
    local aoi_newBlockProcess = function(tester, newAoiBlocks)
        for k,v in pairs(newAoiBlocks) do
            local gridStartPos = BlockID2GridPos(tester, v)
            --根据block位置计算其中所有grid的索引
            for i = 1, tester.gridsOneBlock do
                for j = 1, tester.gridsOneBlock do
                    local gridIndex = (gridStartPos.x + j ) + ((gridStartPos.y + i -1) * tester.gridsOneBlock * 5) --gridsFiveBlocks全局地图宽度
                    local buildingdata = tester._buildingdata[gridIndex] --这里相当于约定 _buildingdata 使用的是 gridid 作为索引
                    --先从 BuildingsOutAoi 中提取指定类型的对象， 没有再检查  defaultInstancePools ， 没有再 实例化
                    --BuildingsOutAoi
                    local validInstance = getInstance(tester.BuildingsOutAoi, buildingdata.typeid) --这里不允许分配新的实例
                    --defaultInstancePools
                    if validInstance == nil then
                        validInstance = getInstance(tester.defaultInstancePools, buildingdata.typeid, true) --只有默认对象池才允许分配新实例
                    end
                    if validInstance then
                        validInstance.transform.position.x = buildingdata.position.x
                        validInstance.transform.position.z = buildingdata.position.y
                    end
                    tester.BuildingsInAoi[gridIndex] = validInstance --BuildingsInAoi表使用gridid作为key
                end
            end
            tester.AoiScreenBlocks[k] = v
        end
        newAoiBlocks = {}  --清空新增表
    end

    local RelocateFun = function(tester)
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()
        tester.AoiScreenBlocksNewIn = {}    --新增的分块
        tester.AoiScreenBlocksOut = {}   --原来有的，现在超出范围了
        --中心屏幕坐标,这里随机取非边缘的分块位置, 中心坐标x,y在(2-4)之间随机，边缘在1-5之间，也就是(1,1)-(5,5)之间，
        --注意不是(0,0)-(4,4)
        local aoiCenterScreenPos = {
        x = math.random(2,aTester.ScreenBlockSizeWorld-1),
        y = math.random(2,aTester.ScreenBlockSizeWorld-1)
        }
        --根据新的中心点确定新的aoi 9 屏 block
        tester.AoiScreenBlocksNewIn = aoi_get9ScreenBlock(aoiCenterScreenPos)
        --分拣block， 新旧aoi中都有的，保留； 新增的block放到 AoiScreenBlocksNewIn ； 超出范围的放入 AoiScreenBlocksOut
        filterAoiBlocks(tester)

        --aoi 建筑实例处理
        gridsOutProcessing(tester)
        aoi_newBlockProcess(tester, newAoiScreenBlockArea)
    end

    --从超出范围的块中提取对象
    --原有9屏分块与新的Aoi分块的比对，都有的，不用变，新增的，放到
    if aTester.relocateTestExcutePos > aTester.relocateTestExcuteCount then
        tester._timerRelocate:Stop()
        return curSeq.postfun(tester)
    end
    --未优化版本，9屏全部更新
    for i = 1, tester.relocateTestCountEveryExcute do
        tester.relocateStartPos = tester.relocateStartPos + 1
        if tester.relocateStartPos > tester.testcount then
        tester.relocateStartPos = 1
        end
        local transform = tester.instances[tester.relocateStartPos].transform
        if transform ~= nil then
        transform.position.x = math.random(1000)
        transform.position.z = math.random(1000)
        end
    end

    aTester._timerRelocate = FrameTimer.New(function()
    RelocateFun()
    end, aTester.interval,1)

    local Relocatefun_Loop = function(tester)
    tester._timerRelocate:Start()
    end

    local finishedfun = function(tester)
    ct.log('abel_w17_Aoi_Relocate_3Grid_frameRate',tester._msgs)
    end

    --加载成功后的回调
    local callback = function (tester)
        local nextDelay = tester:getCurSeq()._nextTestDelay
        local costTime = os.clock() - tester.startTime
        collectgarbage("collect")
        tester._msgs = tester._msgs..'\n'..tester:getCurSeq().msg ..costTime
        local timer = FrameTimer.New(function()
        tester:Nextfun()
        tester:excute()
        end, nextDelay,0)
        timer:Start()
    end

    aTester.testcount = 4050
    aTester.testSquence[#aTester.testSquence+1] = { fun = LoadTestRes, _inscount = 1, _nextTestDelay = 60, prefun = nil, postfun = callback, msg = '加载所有建筑资源耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = DefaultInsPoolsSetup, _inscount = 40, _nextTestDelay = 60, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 40 次实例化, '..aTester.testcount..'个实例耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = finishedfun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = ''}

    --开始执行异步测试序列
    collectgarbage("collect")
    aTester:excute()
    --[[
    cpu
        * 4050个 1*1建筑实例，每帧执行 40 次实例化, 4050个实例耗时 =3.995006
        * 设备上稳定在 30 帧
         * 上述测试是在 荣耀9
         * 小米5X 即便打开 unity profile 采集数据的情况下
         * Vivo X20A
         * Oppo R11t
    内存
        * 4050个 1*1建筑实例 内存为

    测试结果
        *
    --]]
end)

UnitTest.TestBlockEnd()-----------------------------------------------------------