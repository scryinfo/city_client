---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by cyz_scry.
--- DateTime: 2018/11/13 16:52
---
UnitTest.TestBlockStart()-------------------------------------------------------
local typeof = tolua.typeof
--Basic test data preparation{
--The current test is a resource IO test of 1,000 160*160 stickers
local testcount = 1000 -- number of resources loaded
local ResPathList = {} -- resource path
for i = 1, testcount do
     ResPathList[i] ='TempIcon/A'..i
end

local ResPathListS = {} -- resource path
for i = 1, testcount do
     ResPathListS[i] ='TempIcon/A'..i
end
--Basic test data preparation}

--Memory testing for asynchronous loading and unloading,
--[[
     Test instruction:
     1. It will only be loaded this way at runtime
     2. Because it is asynchronous, you need to use the timer to delay uninstallation
     3. Because it is asynchronous, it can only be used to test the memory destruction of resource loading, but not the IO delay of resource loading.
         The IO latency test is placed in the synchronous loading test group abel_w17_load_unload_s160_time
--]]

-- Asynchronous loading test
local testLoadFun = function(inBundlelist, inAssertlist,type)
    for i = 1, testcount do
        panelMgr:LoadPrefab_A(ResPathList[i], type, nil,function(self, obj ,ab)
            inBundlelist[#inBundlelist +1] = ab
            inAssertlist[#inAssertlist] = obj
        end)
    end
end

UnitTest.Exec("abel_w17_load_A_sprite_s160_mem", "abel_w17_load_A_sprite_s160_mem",  function ()
    local bundlelist ={}        --Table for storing bundles
    local assetlist ={}

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_sprite_s160_mem','[abel_w17_load_A_sprite_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist,ct.getType(UnityEngine.Sprite))
        collectgarbage("collect")
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_A_texture_s160_mem", "abel_w17_load_A_texture_s160_mem",  function ()
    local bundlelist ={}        --Table for storing bundles
    local assetlist ={}

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_texture_s160_mem','[abel_w17_load_A_texture_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist)
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_A_unload_force_s160_mem", "abel_w17_load_A_unload_force_s160_mem",  function ()
    local bundlelist ={}        --Table for storing bundles
    local assetlist ={}
    -- unloadAllLoadedObjects Way to uninstall test
    local TestUnLoadFun_force = function(reslist )
        ct.log('abel_w17_load_A_unload_force_s160_mem','[testUnLoadFun] #reslist = '..#reslist)
        for k,v in pairs(reslist ) do
            UnityEngine.AssetBundle.Unload(v,true)
            v = nil
        end
        --If unloadAllLoadedObjects is true, then both bundle and asset can be unloaded
    end

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_A_unload_force_s160_mem','[abel_w17_load_A_unload_force_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist, ct.getType(UnityEngine.Sprite))
        local timer = FrameTimer.New(function()
            ct.log('abel_w17_load_A_unload_force_s160_mem','[abel_w17_load_A_unload_force_s160_mem] TestUnLoadFun_force')
            TestUnLoadFun_force(bundlelist)
            bundlelist ={}
            collectgarbage("collect")
        end, 90, 0)
        timer:Start()
    end, 10, 0)
    timer0:Start()
end)

UnitTest.Exec("abel_w17_load_AS_unload_No_force_s160_mem", "abel_w17_load_AS_unload_No_force_s160_mem",  function ()
    local bundlelist ={}        --Table for storing bundles
    local assetlist ={}     --Table for storing assets
    -- Non-unloadAllLoadedObjects unload test
    local TestUnLoadFun_No_Force = function(reslist )
        ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[TestUnLoadFun_No_Force] #reslist = '..#reslist)
        for k,v in pairs(reslist ) do
            UnityEngine.AssetBundle.Unload(v,false)
            v = nil
        end
        for k,v in pairs(assetlist) do
            UnityEngine.Resources.UnloadAsset(v)
            GameObject.DestroyImmediate(v, true)
            v = nil
        end
        assetlist = nil
    end

    local timer0 = FrameTimer.New(function()
        collectgarbage("collect")
        ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[abel_w17_load_AS_unload_No_force_s160_mem] testLoadFun')
        testLoadFun(bundlelist, assetlist)
        local timer = FrameTimer.New(function()
            ct.log('abel_w17_load_AS_unload_No_force_s160_mem','[abel_w17_load_AS_unload_No_force_s160_mem] TestUnLoadFun_No_Force')
            TestUnLoadFun_No_Force(bundlelist)
            bundlelist ={}
            collectgarbage("collect")
        end, 90, 0)
        timer:Start()
    end, 10, 0)
    timer0:Start()

    --Test Results
    --If unloadAllLoadedObjects is true, then both bundle and asset can be unloaded
    --If unloadAllLoadedObjects is false, then the bundle can be unloaded, but the asset loaded into memory cannot be cleared
    --So where are these assets still being referenced?
    --[[
    Reason found:
        It turned out to be because panelMgr:LoadPrefab_A(ResPathList[i], ptype, nil,function(self, obj ,ab)
        ptype is Sprite, passing in this type is actually equivalent to loading the asset first, and then creating a Sprite that references the resource
        In other words, GameObject.DestroyImmediate(v, true) actually only destroyed the Sprite, and did not destroy the asset
    --]]
end)

--Synchronous loading and unloading memory test, this method will not be used to load at runtime, but this test can be used to specify the speed of loading different size textures
--[[
    Need to provide a custom loading interface, to meet:
    1. Conform to the naming convention of our project resources and packages
            1. The bundle name is:
                1. In the relative path (relative to the view directory, there is no'/' at the beginning), the'/' is changed to'_'
                2. The extension is'.unity3d'
            2. Resource name and file name without path and extension
    2. Load the bundle
    3. Load the corresponding resources
    * Note
        * A separate interface needs to be extended in steps 2 and 3, similar to panelMgr:LoadPrefab_S
        * This test requires comparison of loading times of sizes 128 and 160
--]]
UnitTest.Exec("abel_w17_load_S_s160_n1000_time", "abel_w17_load_S_s160_n1000_time", function ()
    local assetlist ={}--table for storing assets
    -- Asynchronous loading test
    local testLoadFun_S = function(reslist,type)
        ct.log('abel_w17_load_S_s160_n1000_time','[testLoadFun_S] #reslist = '..#reslist)
        for i = 1, testcount do
            --Note that the value returned here includes two data: asset, bundle
            reslist[#reslist+1] = resMgr:LoadRes_S(ResPathListS[i], type)
        end
    end

    --Size 128 test

     -- Test of size 160
     --Load sprite
     collectgarbage("collect")
     local t1 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n1000_time","[Sprite synchronous load time test]", function()
         testLoadFun_S(assetlist,ct.getType(UnityEngine.Sprite))
     end)
     ct.log('abel_w17_load_S_s160_n1000_time','Time for the simultaneous loading of 1000 160-sized Sprites ='..t1)

     --Uninstall
     for k,v in pairs(assetlist) do
         UnityEngine.AssetBundle.Unload(v._bunldle,true)
         v = nil
     end
     assetlist = {}
     collectgarbage("collect")

     --Load texture
     local t2 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n1000_time","[Texture synchronous load time test]", function()
         testLoadFun_S(assetlist, nil)
     end)
     ct.log('abel_w17_load_S_s160_n1000_time','Time to load synchronously 1000 textures of 160 size ='..t2)
     collectgarbage("collect")

     --[[
     Test Results
    pc
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Sprite同步加载的时间 = 20.255
        [abel_w17_load_S_s160_n1000_time]1000个160大小的Texture同步加载的时间 = 19.454
        *  The performance difference is negligible
        * Loading 33.33 / 20.255 = 1.65 per frame on pc
    equipment
        [abel_w17_load_S_s160_n1000_time] The time for 1000 160 Sprites to load simultaneously = 4.293647
        [abel_w17_load_S_s160_n1000_time] The time for 1000 textures of 160 size to load synchronously = 2.265139
        * The performance difference is obvious, nearly 1 times, but under normal circumstances, when sliding the scroll bar, load 3 screens, 10 screens per screen, then load 10 at a time, then the loading time is
        * 33.33 / 4.293647 = 7.76 loaded every frame on the device
    --]]
end)

-- Sync 30 icons next week
UnitTest.Exec("abel_w17_load_S_s160_n30_time", "abel_w17_load_S_s160_n30_time", function ()
    local testcount = 30
    local assetlist ={}--table for storing assets
    -- Asynchronous loading test
    local testLoadFun_S = function(reslist,type)
        ct.log('abel_w17_load_S_s160_n30_time','[testLoadFun_S] #reslist = '..#reslist)
        for i = 1, testcount do
            --Note that the value returned here includes two data: asset, bundle
            reslist[#reslist+1] = resMgr:LoadRes_S(ResPathListS[i], type)
        end
    end

    --Test of size 128

    -- Test of size 160
    --Load sprite
    collectgarbage("collect")
    local t1 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n30_time","[Sprite同步加载的时间测试]", function()
        testLoadFun_S(assetlist,ct.getType(UnityEngine.Sprite))
    end)
    ct.log('abel_w17_load_S_s160_n30_time','30个160大小的Sprite同步加载的时间 = '..t1)

    --Uninstall
     for k,v in pairs(assetlist) do
        UnityEngine.AssetBundle.Unload(v._bunldle,true)
        v = nil
    end
    assetlist = {}
    collectgarbage("collect")

    --Load texture
    local t2 = UnitTest.PerformanceTest("abel_w17_load_S_s160_n30_time","[Texture synchronous loading time test]", function()
        testLoadFun_S(assetlist, nil)
    end)
    ct.log('abel_w17_load_S_s160_n30_time','Time to load synchronously 30 Textures of 160 size ='..t2)
    collectgarbage("collect")

    --[[
    Test Results
    pc
        ...
    equipment
        [abel_w17_load_S_s160_n30_time] The time for 30 160 sprites to load simultaneously = 0.227158
        [abel_w17_load_S_s160_n30_time] The time for 30 160 Textures to load synchronously = 0.119937
        * The performance difference is obvious, 1 times
        * Based on one frame of 0.03333 seconds, it takes 0.227158/0.03333 = 6.8 to load 30 sprites synchronously, nearly 7 frames
        * Asynchronous will be much faster than this
    --]]
end)

-- Asynchronously load 1000 160 icon time test
UnitTest.Exec("abel_w17_load_A_s160_n1000_time", "abel_w17_load_A_s160_n1000_time",  function ()
    --Size 160 test
     local aTester = AsyncSequenceTester:new()

     -- Initialize test data
     aTester.testcount = 1000
     aTester.loadCount = 0
     aTester.bundlelist = {}
     aTester.assertlist = {}
     aTester.startTime = 0
     aTester.ResPathList = ResPathList
     aTester.curPos = 1
     aTester.testSquence = {}

     -- Asynchronous load test with callback
     local testLoadFunA = function(type, testData, cb)
         for i = 1, testData.testcount do
             panelMgr:LoadPrefab_A(testData.ResPathList[i], type, testData,cb)
         end
     end

     --Callback after successful loading
    local callback = function (testData, obj , ab)
        testData.bundlelist[#testData.bundlelist +1] = ab
        testData.assertlist[#testData.assertlist] = obj
        testData.loadCount = testData.loadCount + 1
        if testData.loadCount >= testData.testcount then
            local costTime = os.clock() - testData.startTime
            ct.log('abel_w17_load_A_s160_n1000_time',testData:getCurSeq().msg ..costTime)

            --Uninstall

            local pos = #testData.bundlelist
            while pos > 0 do
                if testData.bundlelist[pos] ~= nil then
                    resMgr:UnloadAssetBundle(testData.bundlelist[pos].name, true)
                    --UnityEngine.AssetBundle.Unload(testData.bundlelist[pos],true)
                    table.remove(testData.bundlelist, pos)
                    pos = pos -1
                end
            end

            --testData:Nextfun()
            --collectgarbage("collect")
            --testData:excute()

            local timer = FrameTimer.New(function()
                testData:Nextfun()
                collectgarbage("collect")
                testData:excute()
            end, 90,0)
            timer:Start()
        end
    end

    aTester.testSquence[1] = { fun = testLoadFunA, type = nil, cb = callback, msg = '1000个160大小的 Texture 异步加载的时间 ='}
    aTester.testSquence[2] = { fun = testLoadFunA, type = ct.getType(UnityEngine.Sprite), cb = callback, msg = '1000个160大小的 Sprite 异步加载的时间 = '}

    --Start executing asynchronous test sequence
    collectgarbage("collect")
    aTester:excute()
    --Test of size 128
    --[[
    Test Results
    pc
        [abel_w17_load_A_s160_n1000_time] Asynchronous loading time of 1000 textures of 160 size = 2.2260000000001
        [abel_w17_load_A_s160_n1000_time] The time for asynchronous loading of 1000 Sprites of 160 size = 2.3319999999999
        * The performance difference ratio is not large, the average can load 33.33/2.332 = 14.29 per frame
    equipment
        [abel_w17_load_A_s160_n1000_time] Asynchronous loading time of 1000 textures of 160 size = 6.757779
        [abel_w17_load_A_s160_n1000_time] The time for asynchronous loading of 1000 160-sized Sprites = 6.006067
        * Sprite on the device takes less time to load than Texture
            * This conclusion is consistent with the conclusion of synchronous loading?
        * On average, 33.33/6.006067 = 5.555 can be loaded per frame (texture 33.33/6.757779 = 4.932)
        * Compare synchronous loading
            [abel_w17_load_S_s160_n1000_time] The time for 1000 textures of 160 size to load synchronously = 2.265139
            [abel_w17_load_S_s160_n1000_time] The time for 1000 160 Sprites to load simultaneously = 4.293647
            * Sprite asynchronous loading takes about the same time as synchronous loading; texture synchronous loading time will be much less
            * The program will freeze during synchronous loading
    --]]
end)

--Test the performance overhead of Instantiate and the corresponding destory
UnitTest.Exec("abel_w17_Instantiate_destory_s160_n1000", "abel_w17_Instantiate_destory_s160_n1000",  function ()
    --local resTexture = resMgr:LoadRes_S(ResPathListS[1], LuaHelper.GetType("UnityEngine.Texture2D"))
    --local resTexture = resMgr:LoadRes_S(ResPathListS[1], LuaHelper.GetType("UnityEngine_Texture2DWrap"))
    local tp = ct.getType(UnityEngine.Texture2D)
    local tp1 = ct.getType(UnityEngine.Sprite)

    local resTexture = resMgr:LoadRes_S(ResPathListS[1], ct.getType(UnityEngine.Texture2D))
    --[[
    --Set the texture resource to Readable here, otherwise Instantiate will fail, and the prompt is Instantiating a non-readable texture is not allowed!
     --Reference https://www.cnblogs.com/weigx/p/7300586.html
     --]]
     --resTexture._asset:Apply(true,true)
     local resSprite = resMgr:LoadRes_S(ResPathListS[1], ct.getType(UnityEngine.Sprite))
     local insList_texture = {}
     local insList_sprite = {}

    ct.log('abel_w17_Instantiate_destory_s160_n1000','testcount = '..testcount)

     -- Instantiate 1000 Sprites
     local textureIns = UnitTest.PerformanceTest("abel_w17_Instantiate_destory_s160_n1000","[Time of 1000 Sprite Instantiate]", function()
         for i = 1, testcount do
             insList_sprite[#insList_sprite+1] = UnityEngine.GameObject.Instantiate(resSprite._asset);
         end
     end)

     --Destroy 1,000 instances of Sprete
    local textureIns = UnitTest.PerformanceTest("abel_w17_Instantiate_destory_s160_n1000","[1000 张 Sprite 销毁 的时间]", function()
        for i, v in pairs(insList_sprite) do
            GameObject.DestroyImmediate(v, true)
        end
        insList_sprite = {}
    end)

    --[[
    Test Results
    [abel_w17_Instantiate_destory_s160_n1000][Time of 1000 sheets of Sprite Instantiate] Execution time: 0.014999999999873 One frame of Instantiate 2.22
        * This data is only the instantiation of simple data, complex data may be more time-consuming, so Instantiate must be used with caution
    [abel_w17_Instantiate_destory_s160_n1000] [Time for destruction of 1000 Sprites] Execution time: 0.0029999999997017 11.11 destroyed in one frame
    --]]
end)

--Comparative test of synchronous loading of prefab resources with scroll bars
UnitTest.Exec("abel_w17_load_s128_n400_Sync", "abel_w17_load_s128_n400_Sync", function ()
    --Test data preparation{
    local testcount = 10
    local ResPathList = {}
    for i = 1, testcount do
        ResPathList[i] ='View/TempIcon/A'..i
    end
    --Test data preparation}
    local exectime1 = UnitTest.PerformanceTest("abel_w17_load_s128_n400_Sync","[Synchronously load 400 icons of size 128: Resource.Load]", function()
        local prefab = UnityEngine.Resources.Load('View/TempIcon/Image');

        for i = 1, testcount do
            --Load prefab resources
            local resLoad = UnityEngine.Resources.Load(ResPathList[i])
            local go = UnityEngine.GameObject.Instantiate(resLoad)
            --go.transform:GetComponent("Image").sprite = resLoad
            local xxx = 0
        end
    end)

    local exectime1 = UnitTest.PerformanceTest("abel_w17_load_s128_n400_Sync","[同步加载400个尺寸为128的 Icon: AssetBundle.Load]", function()

    end)

    ct.OpenCtrl('TestSliderCtrl',ResPathList)
end)

---AOI test------------------------------------------------ -------------------------------------------------- -------------------------
--AOI asynchronous load time test
UnitTest.Exec("abel_w17_Aoi_load_building_ASync", "abel_w17_Aoi_load_building_ASync", function ()
    local aTester = AsyncSequenceTester:new()
    -- Initialize test data
    aTester.testcount = 1
    aTester.loadCount = 0
    aTester.bundlelist = {}
    aTester.assertlist = {}
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}

    aTester.resetData = function(self)
        self.bundlelist = {}
        self.assertlist = {}
        self.startTime = 0
    end

    --Asynchronous load test with callback
    local testLoadFunA = function(tester, curSeq)
        for i = 1, tester.testcount do
            panelMgr:LoadPrefab_A(curSeq.path, curSeq.type, tester,curSeq.cb)
        end
    end

    local unloadFun = function(testData)
        for i, v in pairs(testData.testSquence) do
            if v.bundle ~= nil then
                resMgr:UnloadAssetBundle(v.bundle.name, true)
            end
        end
        local costTime = os.clock() - testData.startTime
        ct.log('abel_w17_Aoi_load_building_ASync',testData:getCurSeq().msg ..costTime)
    end

    --Callback after successful loading
    local callback = function (testData, obj , ab)
        testData.testSquence[testData.curPos].bundle = ab
        testData.testSquence[testData.curPos].asset = obj
        testData.loadCount = testData.loadCount + 1
        if testData.loadCount >= testData.testcount then
            local costTime = os.clock() - testData.startTime
            ct.log('abel_w17_Aoi_load_building_ASync',testData:getCurSeq().msg ..costTime)

            --Uninstall
            --local pos = #testData.bundlelist
            --while pos > 0 do
            --    if testData.bundlelist[pos] ~= nil then
            --        resMgr:UnloadAssetBundle(testData.bundlelist[pos].name, true)
            --        table.remove(testData.bundlelist, pos)
            --        pos = pos -1
            --    end
            --end

            local timer = FrameTimer.New(function()
                testData:Nextfun()
                collectgarbage("collect")
                testData:excute()
            end, 15,0)
            timer:Start()
        end
    end

    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/CentralBuilding_Build',msg = 'CentralBuilding_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Factory_3x3_Build',msg = 'Factory_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/MaterialBuilding_3x3_Build',msg = 'MaterialBuilding_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Park_3x3_Build',msg = 'Park_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/SuperMarket_3x3_Build',msg = 'SuperMarket_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Techo_3x3_Build',msg = 'Techo_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/WareHouse_3x3_Build',msg = 'WareHouse_3x3_Build 异步加载的时间 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = unloadFun, type = nil, cb = nil, path = ' ',msg = 'unloadFun 卸载所有建筑的耗时 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Museum',msg = 'Museum 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Park_3x3',msg = 'Park_3x3 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Stadium',msg = 'Stadium 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/TechnologyBuilding_3x3',msg = 'TechnologyBuilding_3x3 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/UnderConstruction_3x3_03',msg = 'UnderConstruction_3x3_03 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/University',msg = 'University 异步加载的时间 ='}
    --aTester.testSquence[#aTester.testSquence+1] = { fun = testLoadFunA, type = ct.getType(UnityEngine.GameObject), cb = callback, path = 'Build/Airport',msg = 'Airport 异步加载的时间 ='}
    
    --Start executing asynchronous test sequence
     collectgarbage("collect")
     aTester:excute()
     --[[
     Test Results
     --Loading time
        PC
            [abel_w17_Aoi_load_building_ASync] Factory_3x3_Build asynchronous loading time = 0.372 - the first one seems to be too long
            [abel_w17_Aoi_load_building_ASync] CentralBuilding_Build asynchronous loading time =0.065000000000001
            [abel_w17_Aoi_load_building_ASync] MaterialBuilding_3x3_Build Asynchronous loading time = 0.096999999999753
            [abel_w17_Aoi_load_building_ASync]Park_3x3_Build asynchronous loading time =0.065999999999804
            [abel_w17_Aoi_load_building_ASync] SuperMarket_3x3_Build asynchronous loading time =0.095999999999549
            [abel_w17_Aoi_load_building_ASync] Time for Techo_3x3_Build to load asynchronously = 0.097999999999956
            [abel_w17_Aoi_load_building_ASync] WareHouse_3x3_Build Asynchronous loading time = 0.096999999999753
        equipment
            [abel_w17_Aoi_load_building_ASync] Factory_3x3_Build asynchronous loading time = 0.515782 - the first time seems to be too long
            [abel_w17_Aoi_load_building_ASync] CentralBuilding_Build asynchronous loading time = 0.330709
            [abel_w17_Aoi_load_building_ASync]MaterialBuilding_3x3_Build Asynchronous loading time=0.308198
            [abel_w17_Aoi_load_building_ASync] Park_3x3_Build asynchronous loading time = 0.232529
            [abel_w17_Aoi_load_building_ASync] SuperMarket_3x3_Build asynchronous loading time = 0.307951
            [abel_w17_Aoi_load_building_ASync] Time for Techo_3x3_Build to load asynchronously = 0.293312
            [abel_w17_Aoi_load_building_ASync] WareHouse_3x3_Build Asynchronous loading time = 0.341899
            It takes about 0.330709/0.0333333333333333 = 9.92127000000001 to load a building. Assuming 10 building types, it takes 0.33*10 = 3.3 seconds to load all buildings
     --Memory usage
        PC
            texture momory 32M
            Total Allocated
                Open test group 249 frames 138.5 M
                Close test group 249 frames 123.8 M
                Test allocated memory 138.5-123.8 = 14.7 M
        equipment
            texture memory 7.7M
                * 7 buildings average 1.1M each
            Total Allocated
                Open test group 122 frames 36.7 M
                Close test packet 122 frames 27.7 M
                Test allocated memory 36.7-27.7 = 9 M
    --Uninstall
        PC
            [abel_w17_Aoi_load_building_ASync]unloadFun time to unload all buildings =0.020000000000437
       equipment
            [abel_w17_Aoi_load_building_ASync]unloadFun time to unload all buildings =0.066083000000001
            * 0.0333333333333333 seconds per frame, then 2 frames can be completely unloaded
    --in conclusion
        All buildings on the device are loaded into memory at 8 or 9M, and the memory burden is not large; while the time cost of building loading is high, the average of a single is about 0.3 seconds, it can be said that it cannot be loaded at runtime.
        Therefore, the loading strategy of the building should be pre-loaded according to the city and resident in memory; the unloading pressure is very small, you don’t need to consider
    --]]
end)

--AOI 9-screen building instantiation time and memory test
UnitTest.Exec("abel_w17_Aoi_Instantiate_9Grid", "abel_w17_Aoi_Instantiate_9Grid", function ()
    local aTester = AsyncSequenceTester:new()
    -- Initialize test data
    aTester.testcount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.instances = {}
    aTester.resetData = function(self)
        self.startTime = 0
    end
    --data preparation
    local ResPathListS = {}
    ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Park_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Techo_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Build'

    aTester.ResPathList = ResPathListS
    --data preparation

    local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            local loadDataInfo =  resMgr:LoadRes_S(tester.ResPathList[i], ct.getType(UnityEngine.GameObject));
            tester.loadedBundles[#tester.loadedBundles+1] = loadDataInfo._bunldle
            tester.loadedAssets[#tester.loadedAssets+1] = loadDataInfo._asset
        end
        tester:getCurSeq().postfun(tester)
    end

    --Instantiation method
    local InstantiateFun = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[InstantiateFun]')
        local curSeq = tester:getCurSeq()
        for i = 1, #aTester.loadedAssets do
            for j = 1, curSeq._inscount do
                tester.instances[#tester.instances+1] = UnityEngine.GameObject.Instantiate(aTester.loadedAssets[i])
            end
        end
        curSeq.postfun(tester)
    end

    local destroyInstances = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[destroyInstances]')
        for i, v in pairs(tester.instances) do
            GameObject.DestroyImmediate(v, true)
        end
        tester.instances = {}
        collectgarbage("collect")
        tester:getCurSeq().postfun(tester)
    end

    local unloadFun = function(tester)
        --ct.log('abel_w17_Aoi_Instantiate_9Grid','[unloadFun]')
        for i, v in pairs(tester.loadedBundles) do
            if v ~= nil then
                UnityEngine.AssetBundle.Unload(v,true)
            end
        end
        for i, v in pairs(tester.loadedAssets) do
            if v ~= nil then
                UnityEngine.Resources.UnloadAsset(v)
            end
        end
        tester.loadedBundles = {}
        tester.loadedAssets = {}
        tester:getCurSeq().postfun(tester)
    end

    --Callback after successful loading
    local callback = function (tester)
        local costTime = os.clock() - tester.startTime
        ct.log('abel_w17_Aoi_Instantiate_9Grid',tester:getCurSeq().msg ..costTime)
        local timer = FrameTimer.New(function()
            tester:Nextfun()
            collectgarbage("collect")
            tester:excute()
        end, 5,0)
        timer:Start()
    end

    aTester.testSquence[#aTester.testSquence+1] = { fun = LoadTestRes, _inscount = 6, prefun = nil, postfun = callback, msg = '加载所有建筑资源耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = InstantiateFun, _inscount = 507, prefun = aTester.resetData, postfun = callback, msg = '1屏450个实例，9屏4050实例的实例化耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = destroyInstances, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '9屏4050实例的销毁耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = InstantiateFun, _inscount = 248, prefun = aTester.resetData, postfun = callback, msg = '1屏220个实例，9屏1980实例的实例化耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = destroyInstances, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '9屏1980实例的销毁耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = unloadFun, _inscount = 0, prefun = aTester.resetData, postfun = callback, msg = '所有(一共'..#aTester.ResPathList..'个)建筑卸载的时间 ='}

    --Start executing asynchronous test sequence
    collectgarbage("collect")
    aTester:excute()
    --[[
    Test Results
    - instantiation time
        PC
            [abel_w17_Aoi_Instantiate_9Grid] 220 instances on 1 screen, time to instantiate instances on 1980 on 9 screens = 4.391
            [abel_w17_Aoi_Instantiate_9Grid] Time to destroy 9-screen 1980 instance = 0.026999999999987
            [abel_w17_Aoi_Instantiate_9Grid] 450 instances on 1 screen, time to instantiate 4050 instances on 9 screens = 4.269
            [abel_w17_Aoi_Instantiate_9Grid]Destroy time of 9 screen 4050 instance =0.057999999999993
            [abel_w17_Aoi_Instantiate_9Grid] Time for all (a total of 7) buildings to be unloaded = 0.0010000000000048
        equipment
            [abel_w17_Aoi_Instantiate_9Grid] Time to load all building resources = 0.698422
            [abel_w17_Aoi_Instantiate_9Grid] 220 instances per screen, time to instantiate 1980 instances on 9 screens = 13.512051
            [abel_w17_Aoi_Instantiate_9Grid] 9 screen 1980 instance destruction time = 0.33568
            [abel_w17_Aoi_Instantiate_9Grid] 450 instances on 1 screen, time to instantiate 4050 instances on 9 screens = 24.404046
            [abel_w17_Aoi_Instantiate_9Grid]Destroy time of 9 screen 4050 instance =0.57482
            [abel_w17_Aoi_Instantiate_9Grid] Time for all (a total of 6) buildings to unload = 0.054358000000001
     --Memory usage
        PC
            texture memory
                Open test group
                    Frame 1 21.1 M
                    Frame 4 32.9 M
            Total Allocated
                Open test group
                    Frame 1 123.6 M
                    Frame 12 294.0 M
                    Frame 26 274.6 M
                    Frame 43 418.2 M
                    370.2 M after frame 47
                Close test group 249 frames 123.8 M
                Test allocated memory 138.5-123.8 = 14.7 M
        equipment
           texture memory
                Open test group
                    Frame 1 21.1 M
                    Frame 4 32.9 M
            Total Allocated
                Open test group
                    LoadTestRes end 30.9 M
                    InstantiateFun 330 over 55,1 M
                    destroyInstances end 41.4 M
                    InstantiateFun 670 over 82.3 M
                    destroyInstances end 52.5 M
                    unloadFun end 43.5 M
                    * 43.5 M remaining
                        Not Saved
                            RenderTexture 26.7
                                TempBuffer 1 1080*2160 17.8 M
                                ImageEffects Temp 8.9 M
                        Other
                            GfxDevice
                                GfxDeviceClient 8 M
                Close test packet 122 frames 27.7 M
                Test allocated memory 36.7-27.7 = 9 M
    --Uninstall
        PC
            [abel_w17_Aoi_load_building_ASync]unloadFun time to unload all buildings =0.020000000000437
       equipment
            [abel_w17_Aoi_load_building_ASync]unloadFun time to unload all buildings =0.066083000000001
            * 0.0333333333333333 seconds per frame, then 2 frames can be completely unloaded
    --in conclusion
        All buildings on the device are loaded into memory at 8 or 9M, and the memory burden is not large; while the time cost of building loading is high, the average of a single is about 0.3 seconds, it can be said that it cannot be loaded at runtime.
        Therefore, the loading strategy of the building should be pre-loaded according to the city and resident in memory; the unloading pressure is very small, you don’t need to consider

        1 second can be instantiated 4050/24.404046 = 165.9560877733143
        1 frame instantiation 165.9560877733143/30 = 5.53186959244381
        1 instantiation takes 24.404046/4050 = 0.0060256903703704 seconds
        1 screen instantiation takes time 450 * 0.0060256903703704 = 2.71156066666668
    --]]
end)

--AOI 9 screen 4050 objects instantiated and put into the object pool frame rate test
--[[
It takes time to instantiate 1 screen 450 * 0.0060256903703704 = 2.71156066666668 seconds, then just count on one screen
8 buildings per instance 450/8 = 56.25 aTester.testcount = 57
    1 instance per frame
    Instantiate 2 per frame
    3 instantiations per frame
    4 instantiations per frame
    5 instantiations per frame
    6 instantiations per frame
    7 instantiations per frame
    8 instantiations per frame
    9 instantiations per frame
    10 instantiations per frame
-]]
UnitTest.Exec("abel_w17_Aoi_Inst_9Grid_frameRate", "abel_w17_Aoi_Inst_9Grid_frameRate", function ()
    local aTester = AsyncSequenceTester:new()
    AsyncSequenceTester.recordTester(aTester)
    -- Initialize test data
    --aTester.testcount = 600
    --aTester.testcount = 2
    aTester.instancedCount = 1
    aTester.resLoadedCount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.loadedAssetsNextIdx = 1
    aTester.instances = {}
    aTester._timer = nil
    aTester._msgs = ''
    aTester.resetData = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
        tester.instancedCount = 1
    end
    --data preparation
    local ResPathListS = {}
    ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Park_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Techo_3x3_Root'
    ResPathListS[#ResPathListS+1] = 'Build/WareHouse_3x3_Root'

    aTester.ResPathList = ResPathListS
    --data preparation

    local LoadedCb = function(tester, as, ab)
        tester.loadedBundles[#tester.loadedBundles+1] = ab
        tester.loadedAssets[#tester.loadedAssets+1] = as
        tester.resLoadedCount = tester.resLoadedCount + 1
        if tester.resLoadedCount > #tester.ResPathList then
            tester:getCurSeq().postfun(tester)
        end
    end
    --Asynchronous load test with callback
     local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            panelMgr:LoadPrefab_A(tester.ResPathList[i], nil, tester,LoadedCb)
        end
    end

    --Instance method
    local InstantiateFun = function()
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()
        --exceed
        if tester.instancedCount> tester.testcount then
            tester._timer:Stop()
            return curSeq.postfun(tester)
        end

        for j = 1, curSeq._inscount do
            tester.instances[#tester.instances+1] = UnityEngine.GameObject.Instantiate(aTester.loadedAssets[aTester.loadedAssetsNextIdx])
            aTester.loadedAssetsNextIdx = aTester.loadedAssetsNextIdx +1
            tester.instancedCount = tester.instancedCount + 1
            --Cycle to extract resources to be instantiated from the resource list
            if aTester.loadedAssetsNextIdx > #aTester.loadedAssets then
                aTester.loadedAssetsNextIdx = 1
            end
        end
    end

    aTester._timer = FrameTimer.New(function()
        InstantiateFun()
    end, 1,1)

    local Insfun_Loop = function(tester)
        tester._timer:Start()
    end

    local destroyInstances = function(tester)
        for i, v in pairs(tester.instances) do
            GameObject.DestroyImmediate(v, true)
        end
        tester.instances = {}
        collectgarbage("collect")
        tester:getCurSeq().postfun(tester)
    end

    local unloadFun = function(tester)
        --ct.log('abel_w17_Aoi_Inst_9Grid_frameRate','[unloadFun]')
        for i, v in pairs(tester.loadedBundles) do
            if v ~= nil then
                UnityEngine.AssetBundle.Unload(v,true)
            end
        end
        for i, v in pairs(tester.loadedAssets) do
            if v ~= nil then
                UnityEngine.Resources.UnloadAsset(v)
            end
        end
        tester.loadedBundles = {}
        tester.loadedAssets = {}
        tester:getCurSeq().postfun(tester)
    end

    local finishedfun = function(tester)
        ct.log('abel_w17_Aoi_Inst_9Grid_frameRate',tester._msgs)
    end
    --Callback after successful loading
    local callback = function (tester)
        local nextDelay = tester:getCurSeq()._nextTestDelay
        local costTime = os.clock() - tester.startTime
        collectgarbage("collect")
        tester._msgs = tester._msgs..'\n'..tester:getCurSeq().msg ..costTime
        local timer = FrameTimer.New(function()
            tester:Nextfun()
            tester:excute()
        end, nextDelay,0)
        timer:Start()
    end

    aTester.testcount = 4050
    aTester.testSquence[#aTester.testSquence+1] = {fun = LoadTestRes, _inscount = 1, _nextTestDelay = 60, prefun = nil, postfun = callback, msg ='Time to load all building resources ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 1, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Execute 1 instantiation per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 2, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Execute 2 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 3, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Perform 3 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 4, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Perform 4 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 5, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Perform 5 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 6, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Execute 6 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 7, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Execute 7 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 8, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Execute 8 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 9, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='Perform 9 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 10, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 10 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 15, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 15 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 20, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 20 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 30, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 30 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 40, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 40 instantiations per frame,'..aTester .testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 80, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Perform 80 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = Insfun_Loop, _inscount = 160, _nextTestDelay = 150, prefun = aTester.resetData, postfun = callback, msg ='Execute 160 instantiations per frame,'. .aTester.testcount..' instances time-consuming ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = destroyInstances, _inscount = 0, _nextTestDelay = 30, prefun = aTester.resetData, postfun = callback, msg = aTester.testcount. ='}
    --aTester.testSquence[#aTester.testSquence+1] = {fun = unloadFun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg ='all (total'..#aTester.ResPathList ..'Times) building unloading time ='}
    aTester.testSquence[#aTester.testSquence+1] = {fun = finishedfun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg =''}

    --Start executing asynchronous test sequence
    collectgarbage("collect")
    aTester:excute()
    --[[
    cpu
        DirectorUpdateAnimationBegin 39.6%
        DirectorUpdateAnimationEnd 30.2%
        * Removed Animator from all buildings, no fixed GC dropped frames
            500 instances
                Stable at 30 frames, no frame rate fluctuations 40 instantiations per frame, 500 instances
            1500 examples
                Stable at 30 frames, no frame rate fluctuations Perform 40 instantiations per frame, 1500 instances take time = 1.464776
            4050 instances
                At the beginning, it stabilized at 30 frames. After a period of time, it continued to fluctuate between 22 and 30. There was no frame rate fluctuation. 40 instantiations were performed per frame, and 4050 instances took time = 5.059065
                                                                                   Perform 40 instantiations per frame, 4050 instances time-consuming = 5.251131
                                     * When the unity profile is updated, it will fluctuate between 22~30, otherwise it will be stable at 30 frames
                * In other words, 4050 instances can actually be supported, but only to limit the number of Animator in the instance (instances with Animator components exceeding 500 will cause high-frequency GC, resulting in sharp fluctuations in the number of frames)
                * Latest test
                    - Stable at 30 frames 40 instantiations per frame, 4050 instances time-consuming = 2.799826
         * The above test is on Honor 9
         * Mi 5X is stable at 29-30 frames even when the unity profile is opened to collect data
         * Vivo X20A is stable at 29-30 frames
         * Oppo R11t
    RAM
       4050 instances 66.3M of memory on the device
       * Can be resident in memory
    Test Results
        500 instances
            30 frames on the device, 40 instantiations per frame, 500 instances = 0.922895
        600 instances
            30 frames on the device, 2 instantiations per frame, 600 instances time = 14.984493
            30 frames on the device, 2 instantiations per frame, 600 instances time = 15.828577
            30 frames on the device, 3 instantiations per frame, 600 instances time-consuming =9.766479
            30 frames on the device, 4 instantiations per frame, 600 instances time = 7.621891
            30 frames on the device, 5 instantiations per frame, 600 instances =5.989155
            30 frames on the device, 6 instantiations per frame, 600 instances = 5.25467
            30 frames on the device, 10 instantiations per frame, 600 instances time = 3.38418
                * During the period, the frame rate will occasionally drop to more than 20 frames
            30 frames on the device, 15 instantiations per frame, 600 instances time = 2.309575
            30 frames on the device, 20 instantiations per frame, 600 instances = 1.870934
                * During the frame rate jitter
            30 frames on the device, 40 instantiations per frame, 600 instances = 1.157611
                            Perform 40 instantiations per frame, 600 instances take time = 1.179974
                            Perform 40 instantiations per frame, 600 instances = 1.188734
                * The frame rate fluctuates 15~20~30, and the lag is not obvious
                * If it is the release version, it should be even less obvious
                            Perform 40 instantiations per frame, 600 instances time-consuming = 0.931607
                            Fluctuation 18~30 frames are not obvious
        1000 instances
            22-30 frames float on the device (always, caused by GC) 40 instantiations are performed per frame, 1000 instances take time = 1.768171
        30 frames on the device, 80 instantiations are performed per frame, 600 instances take time = 0.906708
            * During the period, the frame rate has obvious jitter, and the range is 12~15~30.
        22-30 frames on the device, 2 instantiations per frame, 800 instances time-consuming = 27.511312
            GC causes frame rate fluctuations
        26 frames on the device, 3 instantiations per frame, 1000 instances = 14.984493
    --]]
end)

--Building Aoi update test
--[[
Test Conditions
    450 per screen, up to 3 screens at a time
--]]
UnitTest.Exec("abel_w17_Aoi_Relocate_3Grid_frameRate", "abel_w17_Aoi_Relocate_3Grid_frameRate", function ()
    local aTester = AsyncSequenceTester:new()
    AsyncSequenceTester.recordTester(aTester)
    -- Initialize test data
    --aTester.testcount = 600
    --aTester.testcount = 2
    aTester.instancedCount = 1
    aTester.instancedPoolCount = 1
    aTester.resLoadedCount = 1
    aTester.loadCount = 0
    aTester.startTime = 0
    aTester.curPos = 1
    aTester.testSquence = {}
    aTester.ResPathList = {}
    aTester.loadedBundles = {}
    aTester.loadedAssets = {}
    aTester.loadedAssetsNextIdx = 1
    aTester.instances = {}      --Examples in use
    aTester.defaultInstancePools = {} -- object pool, idle instances
    aTester._timer = nil
    aTester._msgs =''
    aTester.resetData = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
        tester.instancedCount = 1
    end
    --data preparation
    local ResPathListS = {}
    --ResPathListS[#ResPathListS+1] = 'Build/SuperMarket_1x1_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/CentralBuilding_Root'
    ResPathListS[#ResPathListS+1] = 'Build/Factory_1x1_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/HomeHouse_1x1_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/MaterialBuilding_1x1_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/Park_1x1_Root'
    --ResPathListS[#ResPathListS+1] = 'Build/Techo_1x1_Root'as.Brief
    --ResPathListS[#ResPathListS+1] = 'Build/WareHouse_1x1_Root'

    --aTester.testcount = 4050
    aTester.testcount = 4050 --450 1 screen
    --aTester.testcount = 2700 --300 1 screen
    --aTester.testcount = 360 --40 1 screen
    aTester.CountEachType = math.ceil(aTester.testcount / #ResPathListS)
    aTester.ResPathList = ResPathListS
    aTester.gridsOneBlock = 21 --1 screen horizontal and vertical coordinate span
    aTester.data_25Screen = (aTester.gridsOneBlock * 5)^2 --11025
    aTester._buildingdata = {}
    local gridsFiveBlocks = aTester.gridsOneBlock * 5 -- global map width
    --9 screen Aoi
    aTester.relocateStartPos = 1
    aTester.relocateTestExcuteCount = 600 -- the total batch of relocate
    --aTester.relocateTestExcuteCount = 2 --Total batch of relocate
    aTester.relocateTestExcutePos = 1 -- the currently executed batch
    aTester.ScreenBlockSizeWorld = {x = 5, y = 5}--the number of aoi blocks in the entire map, one unit is equivalent to 1 screen, currently 5 screens each horizontally and vertically, 21*21 building units per screen
    aTester.AoiScreenBlockSize = {x = 3, y = 3} -- the actual screen data to be instantiated, forming a rectangular area
    aTester.AoiScreenBlocks = {} -- actual Aoi blocks
    aTester.BuildingsInAoi = {} --Buildings in blocks
    aTester.AoiScreenBlocksNewIn = {} -- New block
    aTester.AoiScreenBlocksOut = {} --Blocks beyond 9 screens
    aTester.BuildingsOutAoi = {} --The blocks exceeding 9 screens are put into the temporary recycling pool AoiGridsOut
    --Note: The building in the new block is obtained from the block that exceeds the feedback, if not, it is instantiated
    --aTester.interval = 10 - Interval frame for each test
    aTester.interval = 60 -- Interval frame for each test
    aTester.instancCount = 0 -- Interval frame for each test
    aTester._AoiUpdateTimer = nil -- every time a new timer for Aoi data split-screen update is added
    aTester._AoiUpdateTimerInterval = 1 -- every Aoi interval frame
    aTester._AoiUpdateBlockCountEachTime = 1 -- the number of screens updated each time by Aoi
    aTester.updatedBlockCount = 1 -- The number of screens that Aoi has updated each time
    aTester.outRange_Pos = {x = -10000, y = 0, z = -10000}
    aTester.temp_Pos = {x = -10000, y = 0, z = -10000}

    --data preparation

    local LoadedCb = function(tester, as, ab)
        tester.loadedBundles[ab.name] = ab
        tester.loadedAssets[as.name] = as
        tester.resLoadedCount = tester.resLoadedCount + 1
        if tester.resLoadedCount > #tester.ResPathList then
            tester:getCurSeq().postfun(tester)
        end
    end
    --Asynchronous load test with callback
     local LoadTestRes = function(tester)
        for i = 1, #tester.ResPathList do
            panelMgr:LoadPrefab_A(tester.ResPathList[i], nil, tester,LoadedCb)
        end
    end

    --Add the specified type and number of objects to the default object pool
    local extendInstancePool = function(pools, typeid, count)
        local tester = AsyncSequenceTester.Tester()

        if pools[typeid] == nil then
            pools[typeid] = {}
        end

        for i = 1, count do
            pools[typeid][#pools[typeid]+1] = UnityEngine.GameObject.Instantiate(tester.loadedAssets[typeid])
            tester.instancCount = tester.instancCount + 1
            pools[typeid][#pools[typeid]].name = typeid
            pools[typeid][#pools[typeid]].transform.position = tester.outRange_Pos
            --Temporarily name the instance as the resource path, so that when the subsequent instance is migrated to a different object pool, it can be identified
            --[[
                local instanceToPools = function(pools, instance)
                    local typeid = instance.name
            ]]--
        end
    end

    local getPoolSize = function(pools, typeid)
        if pools[typeid] == nil then
            return 0
        else
            return  #pools[typeid]
        end
    end

    --Get specific types of instances from the default object pool, if not and allocate == true, instantiate 40 at a time
    local getInstance = function(pools, typeid, allocate)
        local validInstance = nil
        local outPool = pools[typeid]
        if outPool == nil then
            return validInstance
        end
        validInstance = outPool[#outPool]
        if allocate ~= nil and allocate == true then
            -- instantiation
            if validInstance == nil then
                extendInstancePool(pools, typeid, 40) -- instantiating 40 in one frame will not affect performance
            end
        end
        --Remove the instance from the object pool (otherwise there will be multiple object pools using an instance at the same time, which is wrong)
        validInstance = outPool[#outPool]
        if outPool[#outPool] ~= nil then
            outPool[#outPool] = nil
        end
        return validInstance
    end
    -- Put the instance back into the object pool
    local instanceToPools = function(pools, instance)
        local typeid = instance.name
        if pools[typeid] == nil then
            pools[typeid] = {}
        end
        pools[typeid][#pools[typeid]+1] = instance -- note that there is no type check here, you need to ensure that the type is correct when using it
    end

    --Create a default object pool
    local DefaultInsPoolsSetup = function()
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()


        local pollsize = getPoolSize(tester.defaultInstancePools, tester.ResPathList[tester.loadedAssetsNextIdx])
        if pollsize >= tester.CountEachType then --When the number of resource instances of each type is greater than the limited number, start the instantiation of another resource type
            tester.loadedAssetsNextIdx = tester.loadedAssetsNextIdx + 1
            --exceed
            if tester.loadedAssetsNextIdx> #tester.ResPathList then --loadedAssetsNextIdx is greater than the number of ResPathList resource types, indicating that the object pools of all resource types are established
                tester._timer:Stop()
                return curSeq.postfun(tester)
            end
        end
        --Create an object pool and create object pools according to resource paths; only create curSeq._inscount instances at a time (40 per frame can be guaranteed)
        extendInstancePool(tester.defaultInstancePools,tester.ResPathList[tester.loadedAssetsNextIdx],curSeq._inscount)
    end

    aTester._timer = FrameTimer.New(function()
        DefaultInsPoolsSetup()
    end, 1,1)

    local DefaultInsPoolsSetup = function()
        local tester = AsyncSequenceTester.Tester()
        tester._timer:Start()
    end

    local builddata = {uuid ='xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx', typeid ='',position={x=0,y=0 }}
    --Building relocation test -------------------------------------------- ---------------
    -- Currently using 25 screens as the entire game map to test ------------------------------------{
    --[[
        One screen 450 is equivalent to 21*21=441 grids
        25 screens is equivalent to (21*5)^2 = 11025 grid units, length and width are 105 units
    --]]


    --This is equivalent to the convention _buildingdata uses gridid ​​as the index
    for i = 1, gridsFiveBlocks do
        for j = 1, gridsFiveBlocks do
            local gridId = i + (j-1) * gridsFiveBlocks
            aTester._buildingdata[gridId] = {
                                            uuid = 'xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx',
                                            typeid = ResPathListS[math.random(1, #ResPathListS)],
                                            position=
                                            {
                                                 x = i ,
                                                 y = j
                                            }
            }
        end
    end
    local buildingCount = #aTester._buildingdata --See if it is the expected quantity 11025
    --25 screen data ------------------------------------}



    local RelocateResetfun = function()
        local tester = AsyncSequenceTester.Tester()
        tester.startTime = 0
    end



    --According to aoi center, get nine-screen index data
    local aoi_get9ScreenBlock = function(tester, aoiCenterScreenPos)
        local aoiRect = {--aoiRect ranges from (1,1)-(5,5)
        lu = {x = aoiCenterScreenPos.x -1, y = aoiCenterScreenPos.y -1}, -- upper left corner
        rb = {x = aoiCenterScreenPos.x +1, y = aoiCenterScreenPos.y +1} -- lower right corner
        }
        local newAoiScreenBlockArea = {}
        --Remove all block ids (all 9 screen ids)
        for x = aoiRect.lu.x, aoiRect.rb.x do
            for y = aoiRect.lu.y, aoiRect.rb.y do
                local id_1D = x + (y-1)*tester.ScreenBlockSizeWorld.x -- because the index of the first element of the array in lua is 1, so here we must ensure that the id starts from 1, x can be guaranteed without -1
                newAoiScreenBlockArea[id_1D] = id_1D -- temporarily the key and value are both block ids
            end
        end
        return newAoiScreenBlockArea
    end

    --Compare the old and new Aoi areas, if they are out of range, put them in AoiScreenBlocksOut, and put them in AoiScreenBlocksNewIn as new blocks
    local filterAoiBlocks = function(tester)
        for k,v in pairs(tester.AoiScreenBlocks) do
            if v ~= nil then
                if tester.AoiScreenBlocksNewIn[v] == nil then--there are blocks in the original Aoi range that are not in the new aoi area, put them in AoiScreenBlocksOut and deal with them separately later
                    tester.AoiScreenBlocksOut[#tester.AoiScreenBlocksOut+1] = v
                    tester.AoiScreenBlocks[k] = nil
                else--all of them, removed from the new area, and the rest of newAoiScreenBlockArea is the newly entered block
                    tester.AoiScreenBlocksNewIn[v] = nil
                end
            end
        end
    end

    --[[
        At this time, only the intersection of old and new aoi data in tester.AoiScreenBlocks, all out of range are recovered to AoiScreenBlocksOut, and newAoiScreenBlockArea only has new entry into the range
        Subsequent operations only need to extract the building type required by newAoiScreenBlockArea from AoiScreenBlocksOut (as an object pool) and update the location. If newAoiScreenBlockArea does not,
        Then re-instantiate (so there are not many to be instantiated)
    --]]
    local BlockID2Pos = function(tester, blockid)
        return {
            x=math.fmod( blockid, tester.ScreenBlockSizeWorld.x ), --x takes the remaining x coordinate
            y=math.modf( blockid / tester.ScreenBlockSizeWorld.x )+1 --y rounds the y coordinate, plus 1 means to start counting from 1
        }
    end

    local BlockPos2GridPos = function(tester, blockPos)
        return {-- here is from (0,0)
            x = (blockPos.x -1) * tester.gridsOneBlock + 1,
            y = (blockPos.y -1) * tester.gridsOneBlock + 1
        }
    end

    local BlockID2GridPos = function(tester,blockid)
        --1D arrays are upgraded to 2D. Note: This is only for block division, currently each block corresponds to 1 screen
        local blockPos = BlockID2Pos(tester, blockid)
        return BlockPos2GridPos(tester, blockPos)
    end
    local gridsOutProcessing = function(tester)
        for k, v in pairs(tester.AoiScreenBlocksOut) do
            local gridStartPos = BlockID2GridPos(tester, v)
            --Calculate the indexes of all grids according to the block position
            for i = 1, tester.gridsOneBlock do
                for j = 1, tester.gridsOneBlock do
                    local gridId = (gridStartPos.x + j) + ((gridStartPos.y + i -1) * tester.gridsOneBlock * 5) --gridsFiveBlocks global map width
                    local outinstance = tester.BuildingsInAoi[gridId]
                    tester.BuildingsInAoi[gridId] = nil
                    if outinstance ~= nil then
                        instanceToPools(tester.BuildingsOutAoi, outinstance) -- put in the activated instance table
                    end
                end
            end
            tester.AoiScreenBlocksOut[k] = nil
        end
    end

    --The first aoi calculation, AoiScreenBlocks is empty, take the building data in the range from aTester._buildingdata
    --Note that the span of a ScreenBlocks is the horizontal and vertical coordinates: gridsOneBlock = 21 --The horizontal and vertical coordinates of the screen
    --The preliminary algorithm is to convert the newAoiScreenBlockArea block id ascending dimension to the grid position, and then take the builddata corresponding to all grids in the block,
    -- Take the object from defaultInstancePools according to builddata.typeid and use builddata.position to set the object position
    --Look behind to see if there is an algorithm that does not require dimensionality increase
    local aoi_newBlockProcess = function(tester, newAoiBlocks)
        local updatedBlockCount = 0
        local updatedInstanceCount = 0
        local temp_Pos = {}
        for k,v in pairs(newAoiBlocks) do
            if tester.updatedBlockCount> tester._AoiUpdateBlockCountEachTime then
                tester.updatedBlockCount = 1
                return
            end
            tester.updatedBlockCount = tester.updatedBlockCount +1
            local gridStartPos = BlockID2GridPos(tester, v)
            --Calculate the indexes of all grids according to the block position
            for i = 1, tester.gridsOneBlock do
                for j = 1, tester.gridsOneBlock do
                    local gridIndex = (gridStartPos.x + j) + ((gridStartPos.y + i -1) * tester.gridsOneBlock * 5) --gridsFiveBlocks global map width
                    local buildingdata = tester._buildingdata[gridIndex] --This is equivalent to the convention _buildingdata uses gridid ​​as the index
                    if buildingdata ~= nil then
                        --First extract objects of the specified type from BuildingsOutAoi, without checking defaultInstancePools, without instantiating
                        --BuildingsOutAoi
                        local validInstance = getInstance(tester.BuildingsOutAoi, buildingdata.typeid) -- new instances are not allowed here
                        --defaultInstancePools
                         if validInstance == nil then
                            validInstance = getInstance(tester.defaultInstancePools, buildingdata.typeid, true) -- Only the default object pool is allowed to allocate new instances
                        end
                        if validInstance then
                            temp_Pos.y = validInstance.transform.position.y
                            temp_Pos.x = buildingdata.position.x
                            temp_Pos.z = buildingdata.position.y
                            validInstance.transform.position = temp_Pos
                            tester.BuildingsInAoi[gridIndex] = validInstance --BuildingsInAoi table uses gridid as key
                            updatedInstanceCount = updatedInstanceCount +1
                        end
                    end
                end
            end
            tester.AoiScreenBlocks[k] = v
            newAoiBlocks[k] = nil
        end
        --updatedInstanceCount is zero, indicating that the update is complete, then it is best to stop the updated timer
        if updatedInstanceCount == 0 then
            tester._AoiUpdateTimer:Stop()
        end
        newAoiBlocks = {} --Clear the newly added table
        --ct.log('abel_w17_Aoi_Relocate_3Grid_frameRate','[aoi_newBlockProcess] count of instance updated ='..updatedInstanceCount)
    end

    local RelocateFun = function(tester)
        local tester = AsyncSequenceTester.Tester()
        local curSeq = tester:getCurSeq()
        tester.AoiScreenBlocksNewIn = {} -- New block
        tester.AoiScreenBlocksOut = {} --Original, now out of range
        -- The center screen coordinates, where the non-edge block positions are randomly selected, the center coordinates x, y are randomly between (2-4), and the edges are between 1-5, which is (1,1)-(5, 5) Between,
        -- Note that it is not (0,0)-(4,4)
        local aoiCenterScreenPos = {
        x = math.random(2,tester.ScreenBlockSizeWorld.x-1),
        y = math.random(2,tester.ScreenBlockSizeWorld.y-1)
        }
        -- Determine the new aoi 9 screen block according to the new center point
        tester.AoiScreenBlocksNewIn = aoi_get9ScreenBlock(tester,aoiCenterScreenPos)
        --ct.log('abel_w17_Aoi_Relocate_3Grid_frameRate','[RelocateFun] aoiCenterScreenPos x='..aoiCenterScreenPos.x..' y='..aoiCenterScreenPos.y)
        --ct.log('abel_w17_Aoi_Relocate_3Grid_frameRate','[RelocateFun] instancCount total ='..tester.instancCount)
        -- Sorting blocks, both in old and new aoi, keep; add new blocks to AoiScreenBlocksNewIn; out of range put in AoiScreenBlocksOut
        filterAoiBlocks(tester)

        local buidingcount = table.getn(tester.BuildingsInAoi)
        --aoi architectural example processing
        gridsOutProcessing(tester)

        tester.updatedBlockCount = 1
        tester._AoiUpdateTimer = FrameTimer.New(function()
            aoi_newBlockProcess(tester, tester.AoiScreenBlocksNewIn)
        end, tester._AoiUpdateTimerInterval,1)
        tester._AoiUpdateTimer:Start()
        buidingcount = table.getn(tester.BuildingsInAoi)

        --Check execution times
        if tester.relocateTestExcutePos > tester.relocateTestExcuteCount then
            tester._timerRelocate:Stop()
            return curSeq.postfun(tester)
        end
        tester.relocateTestExcutePos = tester.relocateTestExcutePos +1
    end

    aTester._timerRelocate = FrameTimer.New(function()
        RelocateFun()
    end, aTester.interval,1)

    local Relocatefun_Loop = function(tester)
    tester._timerRelocate:Start()
    end

    local finishedfun = function(tester)
    ct.log('abel_w17_Aoi_Relocate_3Grid_frameRate',tester._msgs)
    end

    --Callback after successful loading
    local callback = function (tester)
        local nextDelay = tester:getCurSeq()._nextTestDelay
        local costTime = os.clock() - tester.startTime
        collectgarbage("collect")
        tester._msgs = tester._msgs..'\n'..tester:getCurSeq().msg ..costTime
        local timer = FrameTimer.New(function()
        tester:Nextfun()
        tester:excute()
        end, nextDelay,0)
        timer:Start()
    end

    aTester.testSquence[#aTester.testSquence+1] = { fun = LoadTestRes, _inscount = 1, _nextTestDelay = 30, prefun = nil, postfun = callback, msg = '加载所有建筑资源耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = DefaultInsPoolsSetup, _inscount = 40, _nextTestDelay = 30, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 40 次实例化, '..aTester.testcount..'个实例耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = Relocatefun_Loop, _inscount = 40, _nextTestDelay = 90, prefun = aTester.resetData, postfun = callback, msg = '每帧执行 40 次实例化, '..aTester.testcount..'个实例耗时 ='}
    aTester.testSquence[#aTester.testSquence+1] = { fun = finishedfun, _inscount = 0, _nextTestDelay = 5, prefun = aTester.resetData, postfun = callback, msg = ''}

    --Start executing asynchronous test sequence
     collectgarbage("collect")
     aTester:excute()
     --[[
     cpu
         * 4050 1*1 building instances, 40 instantiations per frame, 4050 instances time-consuming = 3.995006
         * Stable at 30 frames on the device
          * The above test is on Honor 9
          * Xiaomi 5X even when the unity profile is opened to collect data
          * Vivo X20A
          * Oppo R11t
     RAM
         * 4050 1*1 building example memory is

     Test Results
        *
    --]]
end)

UnitTest.TestBlockEnd()-----------------------------------------------------------