---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by password.
--- DateTime: 2019/4/2 17:19
---建筑主界面今日营收曲线图
TurnoverDetailPart = class('TurnoverDetailPart', BasePartDetail)
local buildingTs = nil
--
function TurnoverDetailPart:PrefabName()
    return "TurnoverPartDetail"
end
--
function  TurnoverDetailPart:_InitEvent()
    DataManager.ModelRegisterNetMsg(nil,"sscode.OpCode","queryBuildingIncomeMap","ss.BuildingIncome",self.n_OnBuildingIncome,self)
end
--
function TurnoverDetailPart:_InitClick(mainPanelLuaBehaviour)
    self.m_LuaBehaviour = mainPanelLuaBehaviour
end
--
function TurnoverDetailPart:_ResetTransform()
    buildingTs = nil
end
--
function TurnoverDetailPart:_RemoveEvent()
    DataManager.ModelNoneInsIdRemoveNetMsg("sscode.OpCode", "queryBuildingIncomeMap", self.n_OnBuildingIncome,self)
end
--
function TurnoverDetailPart:_RemoveClick()
end

function TurnoverDetailPart:Show(data)
    BasePartDetail.Show(self)
    self.m_data = data
    if buildingTs == nil then
        if data.info then
            buildingTs = data.info.openingTs
        end
    end

    self.xText.text = GetLanguage(27030002)
    self.yText.text = GetLanguage(27030003)
    self.expenditure.text = GetLanguage(19020010)
    self.income.text = GetLanguage(19020008)
    self:_initFunc()
end
function TurnoverDetailPart:Hide()
    BasePartDetail.Hide(self)
    buildingTs = nil
end
--
function TurnoverDetailPart:RefreshData(data)
    if data == nil then
        return
    end
end

function TurnoverDetailPart:_setValue(turnover)
    self.turnover = turnover.todayIncome
    self.pay = turnover.todayPay
end
--
function TurnoverDetailPart:_InitTransform()
    transform = self.transform
    self:_getComponent(self.transform)

end
--
function TurnoverDetailPart:_getComponent(transform)
    self.yScale = transform:Find("down/bg/yScale"):GetComponent("RectTransform");  --Y轴
    self.curve = transform:Find("down/bg/curveBg/curve"):GetComponent("RectTransform");
    self.slide = transform:Find("down/bg/curveBg/curve"):GetComponent("Slide");  --滑动
    self.graph = transform:Find("down/bg/curveBg/curve"):GetComponent("FunctionalGraph");  --绘制曲线
    self.xText = transform:Find("down/bg/xScale/Text"):GetComponent("Text");
    self.expenditure = transform:Find("down/bg/expenditure/expenditureText"):GetComponent("Text");  --支出
    self.income = transform:Find("down/bg/income/incomeText"):GetComponent("Text");  --收入
    self.yText = transform:Find("down/bg/yScale"):GetChild(transform:Find("down/bg/yScale").childCount-1):GetComponent("Text")
end
--
function TurnoverDetailPart:_initFunc()
    --获取营收曲线图 发包
        local msgId = pbl.enum("sscode.OpCode","queryBuildingIncomeMap")
        local lMsg = { id = self.m_data.insId }
        local pMsg = assert(pbl.encode("ss.Id", lMsg))
        CityEngineLua.Bundle:newAndSendMsgExt(msgId, pMsg, CityEngineLua._tradeNetworkInterface1)
    end

function TurnoverDetailPart:n_OnBuildingIncome(info)
    self.graph:Close()
    self.slide:Close()
    local currentTime = TimeSynchronized.GetTheCurrentTime()    --服务器当前时间(秒)
    local ts = getFormatUnixTime(currentTime)
    local second = tonumber(ts.second)
    local minute = tonumber(ts.minute)
    local hour = tonumber(ts.hour)
    if second ~= 0 then
        currentTime = currentTime -second
    end
    if minute ~= 0 then
        currentTime = currentTime - minute * 60
    end
    if hour ~= 0 then
        currentTime = currentTime - hour * 3600
    end
    currentTime = math.floor(currentTime)        --当天0点的时间
    local monthAgo = currentTime - 2592000 + 86400     --30天前的0点
    local updataTime = monthAgo
    local time = {}
    local boundaryLine = {}
    local turnoverTab = {}
    local expendTab = {}
    local buildingTs = buildingTs
    buildingTs = math.floor(buildingTs/1000)
    if tonumber(getFormatUnixTime(buildingTs).second) ~= 0 then
        buildingTs = buildingTs - tonumber(getFormatUnixTime(buildingTs).second)
    end
    if tonumber(getFormatUnixTime(buildingTs).minute) ~= 0 then
        buildingTs = buildingTs - tonumber(getFormatUnixTime(buildingTs).minute) * 60
    end
    if tonumber(getFormatUnixTime(buildingTs).hour) ~= 0 then
        buildingTs = buildingTs - tonumber(getFormatUnixTime(buildingTs).hour) * 3600
    end
    if buildingTs >= monthAgo then
        updataTime = buildingTs
        for i = 1, 30 do
            if tonumber(getFormatUnixTime(updataTime).day) == 1 then
                table.insert(boundaryLine,(updataTime - buildingTs + 86400) / 86400 * 142)
            end
            time[i] = getFormatUnixTime(updataTime).month .. "." .. getFormatUnixTime(updataTime).day
            if updataTime <= currentTime then
                turnoverTab[i] = {}
                turnoverTab[i].coordinate = (updataTime - buildingTs + 86400) / 86400 * 142
                turnoverTab[i].money = 0
                expendTab[i] = {}
                expendTab[i].coordinate = (updataTime - buildingTs + 86400) / 86400 * 142
                expendTab[i].money = 0
                if info.nodes ~= nil then
                    for k, v in pairs(info.nodes) do
                        if updataTime == v.time /1000 then
                            turnoverTab[i].money = tonumber(GetClientPriceString(v.income))
                            expendTab[i].money = tonumber(GetClientPriceString(v.pay))
                        end
                    end
                end
                if updataTime == currentTime then
                    turnoverTab[i].money = tonumber(GetClientPriceString(self.turnover))
                    expendTab[i].money = tonumber(GetClientPriceString(self.pay))
                end
            end
            updataTime = updataTime + 86400
        end
    else
        for i = 1, 30 do
            if tonumber(getFormatUnixTime(updataTime).day) == 1 then
                table.insert(boundaryLine,(updataTime - monthAgo + 86400) / 86400 * 142)
            end
            time[i] = getFormatUnixTime(updataTime).month .. "." .. getFormatUnixTime(updataTime).day
            turnoverTab[i] = {}
            turnoverTab[i].coordinate = (updataTime - monthAgo + 86400) / 86400 * 142
            turnoverTab[i].money = 0
            expendTab[i] = {}
            expendTab[i].coordinate = (updataTime - monthAgo + 86400) / 86400 * 142
            expendTab[i].money = 1
            if info.nodes ~= nil then
                for k, v in pairs(info.nodes) do
                    if updataTime == v.time then
                        turnoverTab[i].money = tonumber(GetClientPriceString(v.income))
                        expendTab[i].money = tonumber(GetClientPriceString(v.pay))
                    end
                end
            end
            updataTime = updataTime + 86400
        end
        turnoverTab[#turnoverTab].money = tonumber(GetClientPriceString(self.turnover))
        expendTab[#expendTab].money = tonumber(GetClientPriceString(self.pay))
    end

    --转换为Vector2类型
    local turnover = {}
    local expend = {}
    for i, v in pairs(turnoverTab) do
        turnover[i] = Vector2.New(v.coordinate,v.money)
    end
    for i, v in pairs(expendTab) do
        expend[i] = Vector2.New(v.coordinate,v.money)
    end
    table.insert(time,1,"0")
    table.insert(boundaryLine,1,0)
    table.insert(turnover,1,Vector2.New(0,0))
    table.insert(expend,1,Vector2.New(0,0))
    local max = 0
    for i, v in pairs(turnover) do
        if v.y > max then
            max = v.y
        end
    end
    for i, v in pairs(expend) do
        if v.y > max then
            max = v.y
        end
    end
    local scale = SetYScale(max,4,self.yScale)
    local turnoverVet = {}
    for i, v in pairs(turnover) do
        if scale == 0 then
            turnoverVet[i] = v
        else
            turnoverVet[i] = Vector2.New(v.x,v.y / scale * 100)
        end
    end
    local expendVet = {}
    for i, v in pairs(expend) do
        if scale == 0 then
            expendVet[i] = v
        else
            expendVet[i] = Vector2.New(v.x,v.y / scale * 100)
        end
    end
    local difference = (currentTime - buildingTs) / 86400  --距离开业的天数
    if difference < 12 then
        self.curve.anchoredPosition = Vector3.New(-80, 42,0)
        self.curve.sizeDelta = Vector2.New(1760, 402)
    elseif difference < 30 then
        self.curve.anchoredPosition = Vector3.New(-80, 42,0)
        self.curve.sizeDelta = Vector2.New(1760, 402)
        self.curve.anchoredPosition = Vector3.New(self.curve.anchoredPosition.x - (difference - 12) * 142, 42,0)
        self.curve.sizeDelta = Vector2.New(self.curve.sizeDelta.x + (difference-12) * 142, 402)
    else
        self.curve.anchoredPosition = Vector3.New(-2646, 42,0)
        self.curve.sizeDelta = Vector2.New(4326, 402)
    end

    self.slide:SetXScaleValue(time,142)
    self.graph:BoundaryLine(boundaryLine)

    self.graph:DrawLine(turnoverVet,Color.New(53 / 255, 72 / 255, 117 / 255, 255 / 255),1)
    self.slide:SetCoordinate(turnoverVet,turnover,Color.New(41 / 255, 61 / 255, 108 / 255, 255 / 255),1)

    self.graph:DrawLine(expendVet,Color.New(255 / 255, 0 / 255, 0 / 255, 255 / 255),2)
    self.slide:SetCoordinate(expendVet,expend,Color.New(255 / 255, 0 / 255, 0 / 255, 255 / 255),2)
end
